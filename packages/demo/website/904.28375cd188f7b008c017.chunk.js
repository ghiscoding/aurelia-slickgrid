"use strict";(self.webpackChunkaurelia_slickgrid_demo=self.webpackChunkaurelia_slickgrid_demo||[]).push([[904],{68904:(e,t,i)=>{i.r(t),i.d(t,{Example26:()=>D});var n={};i.r(n),i.d(n,{default:()=>c,dependencies:()=>m,name:()=>r,register:()=>h,template:()=>d});var l={};i.r(l),i.d(l,{default:()=>y,dependencies:()=>w,name:()=>v,register:()=>x,template:()=>C});var o={};i.r(o),i.d(o,{default:()=>S,dependencies:()=>I,name:()=>A,register:()=>O,template:()=>M});var a=i(22970),s=i(26207);const r="example26",d='<template>\n  <h2>\n    ${title}\n    <span class="float-end">\n      <a style="font-size: 18px"\n         target="_blank"\n         href="https://github.com/ghiscoding/aurelia-slickgrid/blob/master/src/examples/slickgrid/example26.ts">\n        <span class="fa fa-link"></span> code\n      </a>\n    </span>\n  </h2>\n  <div class="subtitle" innerhtml.bind="subTitle"></div>\n\n  <div class="col-sm-6">\n    <label>autoEdit setting</label>\n    <br />\n    <span id="radioAutoEdit">\n      <div class="row">\n        <div class="col">\n          <label class="radio-inline control-label" for="radioTrue">\n            <input type="radio" name="inlineRadioOptions" id="radioTrue" checked value.bind="isAutoEdit"\n                   click.trigger="setAutoEdit(true)"> ON\n            (single-click)\n          </label>\n          <label class="radio-inline control-label" for="radioFalse">\n            <input type="radio" name="inlineRadioOptions" id="radioFalse" value.bind="isAutoEdit"\n                   click.trigger="setAutoEdit(false)"> OFF\n            (double-click)\n          </label>\n        </div>\n      </div>\n      <div class="row">\n        <div class="col">\n          <button class="btn btn-outline-secondary btn-sm" click.trigger="undo()">\n            <i class="fa fa-undo"></i>\n            Undo last edit(s)\n          </button>\n          <label class="checkbox-inline control-label" for="autoCommitEdit">\n            <input type="checkbox" id="autoCommitEdit" value.bind="gridOptions.autoCommitEdit"\n                   click.trigger="changeAutoCommit()">\n            Auto Commit Edit\n          </label>\n        </div>\n      </div>\n    </span>\n    <div class="row" style="margin-top: 5px">\n      <div class="col">\n        <button class="btn btn-outline-secondary btn-sm" click.trigger="aureliaGrid.filterService.clearFilters()">Clear\n          Filters</button>\n        <button class="btn btn-outline-secondary btn-sm" click.trigger="aureliaGrid.sortService.clearSorting()">Clear\n          Sorting</button>\n      </div>\n    </div>\n  </div>\n\n  <div class="col-sm-6">\n    <div class="alert alert-info" show.bind="updatedObject">\n      <strong>Updated Item:</strong> ${updatedObject | stringify}\n    </div>\n    <div class="alert alert-warning" show.bind="alertWarning">\n      ${alertWarning}\n    </div>\n  </div>\n\n  <div id="grid-container" class="col-sm-12">\n    <aurelia-slickgrid grid-id="grid26"\n                       column-definitions.bind="columnDefinitions"\n                       grid-options.bind="gridOptions"\n                       dataset.bind="dataset"\n                       instances.bind="aureliaGrid"\n                       on-cell-change.trigger="onCellChanged($event.detail.eventData, $event.detail.args)"\n                       on-click.trigger="onCellClicked($event.detail.eventData, $event.detail.args)">\n    </aurelia-slickgrid>\n  </div>\n</template>\n',c=d,m=[];let u;function h(e){u||(u=s.b_N.define({name:r,template:d,dependencies:m})),e.register(u)}var g=i(23490);class p{args;aureliaViewModel;defaultId;defaultItem;selectedItem;grid;vm;elmBindingContext;constructor(e){this.args=e,this.grid=e&&e.grid,this.init()}get aureliaUtilService(){let e=this.gridOptions&&this.gridOptions.params&&this.gridOptions.params.aureliaUtilService;return e&&e instanceof g.HPW||(e=this.columnEditor&&this.columnEditor.params&&this.columnEditor.params.aureliaUtilService),e}get collection(){return this.columnDef?.internalColumnEditor?.collection??[]}get columnDef(){return this.args?.column??{}}get columnEditor(){return this.columnDef?.internalColumnEditor??{}}get gridOptions(){return this.grid?.getOptions()??{}}get hasAutoCommitEdit(){return this.args.grid.getOptions().autoCommitEdit}get validator(){return this.columnEditor.validator||this.columnDef.validator}async init(){if(!this.columnEditor?.params?.viewModel)throw new Error("[Aurelia-Slickgrid] For the Editors.aureliaComponent to work properly, you need to fill in the \"templateUrl\" property of your Custom Element Editor.\n      Example: this.columnDefs = [{ id: 'title', field: 'title', editor: { model: new CustomAureliaViewModelFilter(), collection: [...], param: { viewModel: MyVM } },");if(this.columnEditor?.params?.viewModel){const e={grid:this.grid,model:{collection:this.collection}},t=this.columnEditor.params.viewModel;this.vm=await this.aureliaUtilService.createAureliaViewModelAddToSlot(t,e,this.args.container),this.elmBindingContext=this.vm?.controller?.children?.[0].scope.bindingContext}}save(){const e=this.validate();e&&e.valid&&(this.hasAutoCommitEdit?this.args.grid.getEditorLock().commitCurrentEdit():this.args.commitChanges())}cancel(){this.elmBindingContext&&(this.elmBindingContext.selectedItem=this.defaultItem),this.args?.cancelChanges&&this.args.cancelChanges()}destroy(){this.vm?.controller?.deactivate(this.vm.controller,null)}hide(){this.elmBindingContext?.hide()}show(){this.elmBindingContext?.focus()}focus(){this.elmBindingContext?.focus()}applyValue(e,t){e[this.columnDef.field]=t}getValue(){return this.elmBindingContext?.selectedItem.id}loadValue(e){const t=e?.[this.columnDef.field];this.selectedItem=t,this.defaultItem=t,setTimeout((()=>{this.focus(),this.elmBindingContext&&(this.elmBindingContext.selectedItem=t,this.elmBindingContext.selectedItemChanged=e=>{this.selectedItem=e,e!==t&&this.save()})}),0)}serializeValue(){return this.selectedItem}isValueChanged(){return!(""===this.selectedItem.id&&(null===this.defaultId||void 0===this.defaultId))&&this.selectedItem.id!==this.defaultId}validate(){if(this.validator){const e=this.selectedItem.id;return this.validator(e,this.args)}return{valid:!0,msg:null}}}class f{_shouldTriggerQuery=!0;container;grid;searchTerms=[];columnDef;callback;operator=g.$MC.equal;vm;elmBindingContext;get aureliaUtilService(){let e=this.gridOptions?.params?.aureliaUtilService;return e&&e instanceof g.HPW||(e=this.columnFilter?.params?.aureliaUtilService),e}get collection(){return this.columnFilter?.collection??[]}get columnFilter(){return this.columnDef?.filter??{}}get gridOptions(){return this.grid?.getOptions()??{}}async init(e){if(this.grid=e.grid,this.callback=e.callback,this.columnDef=e.columnDef,this.searchTerms=(e.hasOwnProperty("searchTerms")?e.searchTerms:[])||[],!this.columnFilter?.params?.viewModel)throw new Error("[Aurelia-Slickgrid] For the Filters.aureliaComponent to work properly, you need to fill in the \"viewModel\" property of your Custom Element Filter.\n      Example: this.columnDefs = [{ id: 'title', field: 'title', filter: { model: new CustomAureliaViewModelFilter(), collection: [...], param: { viewModel: MyVM } },");if(this.columnFilter.params.viewModel){this.container=this.grid.getHeaderRowColumn(this.columnDef.id),(0,g.EUQ)(this.container);const e={grid:this.grid,model:{collection:this.collection}},t=this.columnFilter.params.viewModel;this.vm=await this.aureliaUtilService.createAureliaViewModelAddToSlot(t,e,this.container),this.elmBindingContext=this.vm?.controller?.children?.[0].scope.bindingContext,this.elmBindingContext&&(this.elmBindingContext.selectedItemChanged=e=>{this.callback(void 0,{columnDef:this.columnDef,operator:this.operator,searchTerms:[e.id],shouldTriggerQuery:this._shouldTriggerQuery}),this._shouldTriggerQuery=!0})}}clear(e=!0){this._shouldTriggerQuery=e,this.elmBindingContext?.selectedItem&&(this.elmBindingContext.selectedItem={id:"",name:""})}destroy(){this.vm?.controller?.deactivate(this.vm.controller,null),this.container=this.grid.getHeaderRowColumn(this.columnDef.id),(0,g.EUQ)(this.container)}setValues(e){this.elmBindingContext?.selectedItem&&(this.elmBindingContext.selectedItem=e)}}var b=i(59331);const v="editor-select",C='<div>\n  <span if.bind="model.collection">\n    <select class="form-control form-select" value.bind="selectedItem" matcher.bind="itemMatcher">\n      <option repeat.for="item of model.collection" model.bind="item">\n        ${item.name}\n      </option>\n    </select>\n  </span>\n</div>\n',y=C,w=[];let E;function x(e){E||(E=s.b_N.define({name:v,template:C,dependencies:w})),e.register(E)}i(41414);let k=class{elm;model;grid;selectedItem;itemMatcher=(e,t)=>e&&t&&e.id===t.id;constructor(e){this.elm=e}focus(){this.elm.querySelector("select")?.focus()}hide(){this.elm.style.display="none"}show(){this.elm.style.display="block"}selectedItemChanged(){}};(0,a.gn)([(0,s.ExJ)(),(0,a.w6)("design:type",Object)],k.prototype,"model",void 0),(0,a.gn)([(0,s.ExJ)(),(0,a.w6)("design:type",Object)],k.prototype,"grid",void 0),(0,a.gn)([s.ExJ,(0,a.w6)("design:type",Object)],k.prototype,"selectedItem",void 0),k=(0,a.gn)([(0,s.MoW)(l),(0,a.w6)("design:paramtypes",[HTMLElement])],k);const A="filter-select",M='<div>\n  <span if.bind="model.collection">\n    <select class="form-control form-select" value.bind="selectedItem" matcher.bind="itemMatcher">\n      <option repeat.for="item of model.collection" model.bind="item">\n        ${item.name}\n      </option>\n    </select>\n  </span>\n</div>\n',S=M,I=[];let F;function O(e){F||(F=s.b_N.define({name:A,template:M,dependencies:I})),e.register(F)}let U=class{elm;model;grid;selectedItem;itemMatcher=(e,t)=>e&&t&&e.id===t.id;constructor(e){this.elm=e}focus(){this.elm.querySelector("select")?.focus()}selectedItemChanged(){}};(0,a.gn)([(0,s.ExJ)(),(0,a.w6)("design:type",Object)],U.prototype,"model",void 0),(0,a.gn)([(0,s.ExJ)(),(0,a.w6)("design:type",Object)],U.prototype,"grid",void 0),(0,a.gn)([s.ExJ,(0,a.w6)("design:type",Object)],U.prototype,"selectedItem",void 0),U=(0,a.gn)([(0,s.MoW)(o),(0,a.w6)("design:paramtypes",[HTMLElement])],U);let D=class{aureliaUtilService;title="Example 26: Use of Aurelia Custom Elements";subTitle='\n  <h3>Filters, Editors, AsyncPostRender with Aurelia Custom Elements</h3>\n  Grid with usage of Aurelia Custom Elements as Editor &amp; AsyncPostRender (similar to Formatter).\n  <ul>\n    <li>Support of Aurelia Custom Element as Custom Editor (click on any "Assignee" name cell)</li>\n    <ul>\n      <li>That column uses a simple select drodown wrapped in an Aurelia Custom Element\n      <li>Increased Grid Options "rowHeight" &amp; "headerRowHeight" to 45 so that the Custom Element fits in the cell.</li>\n    </ul>\n    <li>Support of Aurelia Custom Element as Custom Filter ("Assignee" columns), which also uses Custom Element\n    <li>The 2nd "Assignee" column (showing in bold text) uses "asyncPostRender" with an Aurelia Custom Element</li>\n    <ul>\n      <li>Why can\'t we use Aurelia Custom Element as Customer Formatter and why do I see a slight delay in loading the data?</li>\n      <li>It\'s totally normal since SlickGrid Formatters only accept strings (synchronously),\n      so we cannot use that (Aurelia requires at least 1 full cycle to render the element), so we are left with SlickGrid "asyncPostRender" and\n      it works but as the name suggest it\'s async users might see noticeable delay in loading the data\n      </li>\n    </ul>\n  </ul>\n  ';_commandQueue=[];aureliaGrid;gridOptions;columnDefinitions=[];dataset=[];updatedObject;isAutoEdit=!0;alertWarning;assignees=[{id:"",name:""},{id:"1",name:"John"},{id:"2",name:"Pierre"},{id:"3",name:"Paul"}];constructor(e){this.aureliaUtilService=e,this.defineGrid()}attached(){this.dataset=this.mockData(100)}defineGrid(){this.columnDefinitions=[{id:"title",name:"Title",field:"title",filterable:!0,sortable:!0,type:g.fSu.string,editor:{model:g.Kob.longText,minLength:5,maxLength:255},minWidth:100,onCellChange:(e,t)=>{console.log(t),this.alertWarning=`Updated Title: ${t.dataContext.title}`}},{id:"assignee",name:"Assignee",field:"assignee",minWidth:100,filterable:!0,sortable:!0,filter:{model:new f,collection:this.assignees,params:{viewModel:U}},queryFieldFilter:"assignee.id",queryFieldSorter:"assignee.name",formatter:g.UgU.complexObject,params:{complexFieldLabel:"assignee.name"},exportWithFormatter:!0,editor:{model:p,collection:this.assignees,params:{viewModel:k}},onCellChange:(e,t)=>{console.log(t),this.alertWarning=`Updated Title: ${t.dataContext.title}`}},{id:"assignee2",name:"Assignee with Aurelia Component",field:"assignee",minWidth:125,filterable:!0,sortable:!0,filter:{model:new f,collection:this.assignees,params:{viewModel:U}},queryFieldFilter:"assignee.id",queryFieldSorter:"assignee.name",formatter:()=>"...",asyncPostRender:this.renderAureliaComponent.bind(this),params:{viewModel:b.e,complexFieldLabel:"assignee.name"},exportCustomFormatter:g.UgU.complexObject},{id:"duration",name:"Duration (days)",field:"duration",filterable:!0,minWidth:100,sortable:!0,type:g.fSu.number,filter:{model:g.x$p.slider,filterOptions:{hideSliderNumber:!1}},editor:{model:g.Kob.slider,minValue:0,maxValue:100}},{id:"complete",name:"% Complete",field:"percentComplete",filterable:!0,formatter:g.UgU.multiple,type:g.fSu.number,editor:{enableRenderHtml:!0,collection:Array.from(Array(101).keys()).map((e=>({value:e,label:e,symbol:'<i class="fa fa-percent" style="color:cadetblue"></i>'}))),customStructure:{value:"value",label:"label",labelSuffix:"symbol"},collectionSortBy:{property:"label",sortDesc:!0},collectionFilterBy:{property:"value",value:0,operator:g.$MC.notEqual},model:g.Kob.singleSelect},minWidth:100,params:{formatters:[g.UgU.collectionEditor,g.UgU.percentCompleteBar]}},{id:"start",name:"Start",field:"start",filterable:!0,filter:{model:g.x$p.compoundDate},formatter:g.UgU.dateIso,sortable:!0,minWidth:100,type:g.fSu.date,editor:{model:g.Kob.date}},{id:"finish",name:"Finish",field:"finish",filterable:!0,filter:{model:g.x$p.compoundDate},formatter:g.UgU.dateIso,sortable:!0,minWidth:100,type:g.fSu.date,editor:{model:g.Kob.date}}],this.gridOptions={asyncEditorLoading:!1,autoEdit:this.isAutoEdit,autoCommitEdit:!1,autoResize:{container:"#demo-container",rightPadding:10},rowHeight:45,editable:!0,enableCellNavigation:!0,enableColumnPicker:!0,enableExcelCopyBuffer:!0,enableFiltering:!0,enableAsyncPostRender:!0,asyncPostRenderDelay:0,editCommandHandler:(e,t,i)=>{this._commandQueue.push(i),i.execute()},params:{aureliaUtilService:this.aureliaUtilService}}}mockData(e,t=0){const i=[];for(let n=t;n<t+e;n++){const e=2e3+Math.floor(10*Math.random()),t=Math.floor(11*Math.random()),l=Math.floor(29*Math.random()),o=Math.round(100*Math.random());i.push({id:n,title:"Task "+n,assignee:n%3?this.assignees[2]:n%2?this.assignees[1]:this.assignees[0],duration:Math.round(100*Math.random())+"",percentComplete:o,percentCompleteNumber:o,start:new Date(e,t,l),finish:new Date(e,t+1,l),effortDriven:n%5==0})}return i}onCellChanged(e,t){console.log("onCellChange",t),this.updatedObject={...t.item}}onCellClicked(e,t){const i=this.aureliaGrid.gridService.getColumnFromEventArguments(t);console.log(i),"edit"===i.columnDef.id?(this.alertWarning=`open a modal window to edit: ${i.dataContext.title}`,this.aureliaGrid.gridService.highlightRow(t.row,1500)):"delete"===i.columnDef.id&&confirm("Are you sure?")&&(this.aureliaGrid.gridService.deleteItemById(i.dataContext.id),this.alertWarning=`Deleted: ${i.dataContext.title}`)}onCellValidation(e,t){alert(t.validationResults.msg)}changeAutoCommit(){return this.gridOptions.autoCommitEdit=!this.gridOptions.autoCommitEdit,this.aureliaGrid.slickGrid.setOptions({autoCommitEdit:this.gridOptions.autoCommitEdit}),!0}renderAureliaComponent(e,t,i,n){if(n.params.viewModel&&e){const t={model:i,grid:this.aureliaGrid.slickGrid};this.aureliaUtilService.createAureliaViewModelAddToSlot(n.params.viewModel,t,e)}}setAutoEdit(e){return this.isAutoEdit=e,this.aureliaGrid.slickGrid.setOptions({autoEdit:e}),!0}undo(){const e=this._commandQueue.pop();e&&Slick.GlobalEditorLock.cancelCurrentEdit()&&(e.undo(),this.aureliaGrid.slickGrid.gotoCell(e.row,e.cell,!1))}};D=(0,a.gn)([(0,s.MoW)(n),(0,a.w6)("design:paramtypes",[g.HPW])],D)}}]);