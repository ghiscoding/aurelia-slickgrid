{"version":3,"file":"index.dev-DuhuQGSj.js","sources":["../../../../node_modules/.pnpm/@aurelia+fetch-client@2.0.0-beta.23/node_modules/@aurelia/fetch-client/dist/esm/index.dev.mjs"],"sourcesContent":["import { DI, resolve, IContainer, factory, IPlatform, IEventAggregator } from '@aurelia/kernel';\n\n/**\n * Serialize an object to a JSON string. Useful for easily creating JSON fetch request bodies.\n *\n * @param body - The object to be serialized to JSON.\n * @param replacer - The JSON.stringify replacer used when serializing.\n * @returns A JSON string.\n */\nfunction json(body, replacer) {\n    return JSON.stringify((body !== undefined ? body : {}), replacer);\n}\n\n/**\n * A simple in-memory storage implementation for cache interceptor\n */\nclass MemoryStorage {\n    constructor() {\n        this.cache = new Map();\n        this.delete = (key) => this.cache.delete(key);\n        this.has = (key) => this.cache.has(key);\n        this.set = (key, value) => this.cache.set(key, value);\n        this.get = (key) => this.cache.get(key);\n        this.clear = () => this.cache.clear();\n    }\n}\n\nconst ICacheStorage = /*@__PURE__*/ DI.createInterface(x => x.singleton(MemoryStorage));\n\n/**\n * A class for configuring HttpClients.\n */\nclass HttpClientConfiguration {\n    constructor() {\n        /**\n         * The base URL to be prepended to each Request's url before sending.\n         */\n        this.baseUrl = '';\n        /**\n         * Default values to apply to init objects when creating Requests. Note that\n         * defaults cannot be applied when Request objects are manually created because\n         * Request provides its own defaults and discards the original init object.\n         * See also https://developer.mozilla.org/en-US/docs/Web/API/Request/Request\n         */\n        this.defaults = {};\n        /**\n         * Interceptors to be added to the HttpClient.\n         */\n        this.interceptors = [];\n        this.dispatcher = null;\n        /** @internal */\n        this._container = resolve(IContainer);\n    }\n    /**\n     * Sets the baseUrl.\n     *\n     * @param baseUrl - The base URL.\n     * @returns The chainable instance of this configuration object.\n     * @chainable\n     */\n    withBaseUrl(baseUrl) {\n        this.baseUrl = baseUrl;\n        return this;\n    }\n    /**\n     * Sets the defaults.\n     *\n     * @param defaults - The defaults.\n     * @returns The chainable instance of this configuration object.\n     * @chainable\n     */\n    withDefaults(defaults) {\n        this.defaults = defaults;\n        return this;\n    }\n    /**\n     * Adds an interceptor to be run on all requests or responses.\n     *\n     * @param interceptor - An object with request, requestError,\n     * response, or responseError methods. request and requestError act as\n     * resolve and reject handlers for the Request before it is sent.\n     * response and responseError act as resolve and reject handlers for\n     * the Response after it has been received.\n     * @returns The chainable instance of this configuration object.\n     * @chainable\n     */\n    withInterceptor(interceptor) {\n        this.interceptors.push(interceptor);\n        return this;\n    }\n    /**\n     * Applies a configuration that addresses common application needs, including\n     * configuring same-origin credentials, and using rejectErrorResponses.\n     *\n     * @returns The chainable instance of this configuration object.\n     * @chainable\n     */\n    useStandardConfiguration() {\n        const standardConfig = { credentials: 'same-origin' };\n        Object.assign(this.defaults, standardConfig, this.defaults);\n        return this.rejectErrorResponses();\n    }\n    /**\n     * Causes Responses whose status codes fall outside the range 200-299 to reject.\n     * The fetch API only rejects on network errors or other conditions that prevent\n     * the request from completing, meaning consumers must inspect Response.ok in the\n     * Promise continuation to determine if the server responded with a success code.\n     * This method adds a response interceptor that causes Responses with error codes\n     * to be rejected, which is common behavior in HTTP client libraries.\n     *\n     * @returns The chainable instance of this configuration object.\n     * @chainable\n     */\n    rejectErrorResponses() {\n        return this.withInterceptor({ response: rejectOnError });\n    }\n    withRetry(config) {\n        const interceptor = this._container.invoke(RetryInterceptor, [config]);\n        return this.withInterceptor(interceptor);\n    }\n    // public withCache(config?: ICacheConfiguration): HttpClientConfiguration {\n    //   const interceptor = this._container.invoke(CacheInterceptor, [config]);\n    //   return this.withInterceptor(interceptor);\n    // }\n    withDispatcher(dispatcher) {\n        this.dispatcher = dispatcher;\n        return this;\n    }\n}\nfunction rejectOnError(response) {\n    if (!response.ok) {\n        throw response;\n    }\n    return response;\n}\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable prefer-template */\n/** @internal */\nconst createMappedError = (code, ...details) => new Error(`AUR${String(code).padStart(4, '0')}: ${getMessageByCode(code, ...details)}`)\n    ;\n\nconst errorsMap = {\n    [99 /* ErrorNames.method_not_implemented */]: 'Method {{0}} not implemented',\n    [5000 /* ErrorNames.http_client_fetch_fn_not_found */]: 'Could not resolve fetch function. Please provide a fetch function implementation or a polyfill for the global fetch function.',\n    [5001 /* ErrorNames.http_client_configure_invalid_return */]: `The config callback did not return a valid HttpClientConfiguration like instance. Received {{0}}`,\n    [5002 /* ErrorNames.http_client_configure_invalid_config */]: `invalid config, expecting a function or an object, received {{0}}`,\n    [5004 /* ErrorNames.http_client_more_than_one_retry_interceptor */]: `Only one RetryInterceptor is allowed.`,\n    [5005 /* ErrorNames.http_client_retry_interceptor_not_last */]: 'The retry interceptor must be the last interceptor defined.',\n    [5003 /* ErrorNames.http_client_configure_invalid_header */]: 'Default headers must be a plain object.',\n    [5006 /* ErrorNames.http_client_invalid_request_from_interceptor */]: `An invalid result was returned by the interceptor chain. Expected a Request or Response instance, but got [{{{0}}]`,\n    [5007 /* ErrorNames.retry_interceptor_invalid_exponential_interval */]: 'An interval less than or equal to 1 second is not allowed when using the exponential retry strategy. Received: {{0}}',\n    [5008 /* ErrorNames.retry_interceptor_invalid_strategy */]: 'Invalid retry strategy: {{0}}',\n};\nconst getMessageByCode = (name, ...details) => {\n    let cooked = errorsMap[name];\n    for (let i = 0; i < details.length; ++i) {\n        const regex = new RegExp(`{{${i}(:.*)?}}`, 'g');\n        let matches = regex.exec(cooked);\n        while (matches != null) {\n            const method = matches[1]?.slice(1);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            let value = details[i];\n            if (value != null) {\n                switch (method) {\n                    case 'join(!=)':\n                        value = value.join('!=');\n                        break;\n                    case 'element':\n                        value = value === '*' ? 'all elements' : `<${value} />`;\n                        break;\n                    default: {\n                        // property access\n                        if (method?.startsWith('.')) {\n                            value = String(value[method.slice(1)]);\n                        }\n                        else {\n                            value = String(value);\n                        }\n                    }\n                }\n            }\n            cooked = cooked.slice(0, matches.index) + value + cooked.slice(regex.lastIndex);\n            matches = regex.exec(cooked);\n        }\n    }\n    return cooked;\n};\n\nconst absoluteUrlRegexp = /^([a-z][a-z0-9+\\-.]*:)?\\/\\//i;\n/**\n * An interface to resolve what fetch function will be used for the http client\n * Default to the global fetch function via global `fetch` variable.\n */\nconst IFetchFn = /*@__PURE__*/ DI.createInterface('fetch', x => {\n    if (typeof fetch !== 'function') {\n        throw createMappedError(5000 /* ErrorNames.http_client_fetch_fn_not_found */);\n    }\n    return x.instance(fetch);\n});\nconst IHttpClient = /*@__PURE__*/ DI.createInterface('IHttpClient', x => x.aliasTo(HttpClient));\n/**\n * An HTTP client based on the Fetch API.\n */\nclass HttpClient {\n    constructor() {\n        /**\n         * The current number of active requests.\n         * Requests being processed by interceptors are considered active.\n         */\n        this.activeRequestCount = 0;\n        /**\n         * Indicates whether or not the client is currently making one or more requests.\n         */\n        this.isRequesting = false;\n        /**\n         * Indicates whether or not the client has been configured.\n         */\n        this.isConfigured = false;\n        /**\n         * The base URL set by the config.\n         */\n        this.baseUrl = '';\n        /**\n         * The default request init to merge with values specified at request time.\n         */\n        this.defaults = null;\n        /**\n         * @internal\n         */\n        this._interceptors = [];\n        /** @internal */\n        this._dispatcher = null;\n        /** @internal */\n        this._createConfiguration = resolve(factory(HttpClientConfiguration));\n        /** @internal */\n        this._fetchFn = resolve(IFetchFn);\n    }\n    /**\n     * The interceptors to be run during requests.\n     */\n    get interceptors() {\n        return this._interceptors.slice(0);\n    }\n    /**\n     * Configure this client with default settings to be used by all requests.\n     *\n     * @param config - A configuration object, or a function that takes a config\n     * object and configures it.\n     * @returns The chainable instance of this HttpClient.\n     * @chainable\n     */\n    configure(config) {\n        let normalizedConfig;\n        if (typeof config === 'object') {\n            const requestInitConfiguration = { defaults: config };\n            normalizedConfig = requestInitConfiguration;\n        }\n        else if (typeof config === 'function') {\n            normalizedConfig = this._createConfiguration();\n            normalizedConfig.baseUrl = this.baseUrl;\n            normalizedConfig.defaults = { ...this.defaults };\n            normalizedConfig.interceptors = this._interceptors;\n            normalizedConfig.dispatcher = this._dispatcher;\n            const c = config(normalizedConfig);\n            if (c != null) {\n                if (typeof c === 'object') {\n                    normalizedConfig = c;\n                }\n                else {\n                    throw createMappedError(5001 /* ErrorNames.http_client_configure_invalid_return */, typeof c);\n                }\n            }\n        }\n        else {\n            throw createMappedError(5002 /* ErrorNames.http_client_configure_invalid_config */, typeof config);\n        }\n        const defaults = normalizedConfig.defaults;\n        if (defaults?.headers instanceof Headers) {\n            // Headers instances are not iterable in all browsers. Require a plain\n            // object here to allow default headers to be merged into request headers.\n            // extract throwing error into an utility function\n            throw createMappedError(5003 /* ErrorNames.http_client_configure_invalid_header */);\n        }\n        const interceptors = normalizedConfig.interceptors;\n        if (interceptors?.length > 0) {\n            // find if there is a RetryInterceptor\n            if (interceptors.filter(x => x instanceof RetryInterceptor).length > 1) {\n                throw createMappedError(5004 /* ErrorNames.http_client_more_than_one_retry_interceptor */);\n            }\n            const retryInterceptorIndex = interceptors.findIndex(x => x instanceof RetryInterceptor);\n            if (retryInterceptorIndex >= 0 && retryInterceptorIndex !== interceptors.length - 1) {\n                throw createMappedError(5005 /* ErrorNames.http_client_retry_interceptor_not_last */);\n            }\n            // const cacheInterceptorIndex = interceptors.findIndex(x => x instanceof CacheInterceptor);\n            // if (cacheInterceptorIndex >= 0) {\n            //   if (retryInterceptorIndex > 0) {\n            //     if (cacheInterceptorIndex < retryInterceptorIndex - 1) {\n            //       throw new Error('The cache interceptor must be defined before the retry interceptor.');\n            //     }\n            //   } else {\n            //     if (cacheInterceptorIndex !== interceptors.length - 1) {\n            //       throw new Error('The cache interceptor is only allowed as the last interceptor or second last before the retry interceptor');\n            //     }\n            //   }\n            // }\n        }\n        this.baseUrl = normalizedConfig.baseUrl;\n        this.defaults = defaults;\n        this._interceptors = normalizedConfig.interceptors ?? [];\n        this._dispatcher = normalizedConfig.dispatcher;\n        this.isConfigured = true;\n        return this;\n    }\n    /**\n     * Starts the process of fetching a resource. Default configuration parameters\n     * will be applied to the Request. The constructed Request will be passed to\n     * registered request interceptors before being sent. The Response will be passed\n     * to registered Response interceptors before it is returned.\n     *\n     * See also https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\n     *\n     * @param input - The resource that you wish to fetch. Either a\n     * Request object, or a string containing the URL of the resource.\n     * @param init - An options object containing settings to be applied to\n     * the Request.\n     * @returns A Promise for the Response from the fetch request.\n     */\n    fetch(input, init) {\n        this._trackRequestStart();\n        let request = this.buildRequest(input, init);\n        return this.processRequest(request, this._interceptors)\n            .then(result => {\n            let response;\n            if (result instanceof Response) {\n                response = Promise.resolve(result);\n            }\n            else if (result instanceof Request) {\n                request = result;\n                // if called directly, context of the fetch fn will be this HttpClient instance\n                // which will throw illegal invokcation\n                response = this._fetchFn.call(void 0, request);\n            }\n            else {\n                throw createMappedError(5006 /* ErrorNames.http_client_invalid_request_from_interceptor */, result);\n            }\n            return this.processResponse(response, this._interceptors, request);\n        })\n            .then(result => {\n            if (result instanceof Request) {\n                return this.fetch(result);\n            }\n            return result;\n        })\n            .then(result => {\n            this._trackRequestEnd();\n            return result;\n        }, error => {\n            this._trackRequestEnd();\n            throw error;\n        });\n    }\n    /**\n     * Creates a new Request object using the current configuration of this http client\n     */\n    buildRequest(input, init) {\n        const defaults = this.defaults ?? {};\n        let request;\n        let body;\n        let requestContentType;\n        const parsedDefaultHeaders = parseHeaderValues(defaults.headers);\n        if (input instanceof Request) {\n            request = input;\n            requestContentType = new Headers(request.headers).get('Content-Type');\n        }\n        else {\n            if (!init) {\n                init = {};\n            }\n            body = init.body;\n            const bodyObj = body !== undefined ? { body: body } : null;\n            const requestInit = { ...defaults, headers: {}, ...init, ...bodyObj };\n            requestContentType = new Headers(requestInit.headers).get('Content-Type');\n            request = new Request(getRequestUrl(this.baseUrl, input), requestInit);\n        }\n        if (!requestContentType) {\n            if (new Headers(parsedDefaultHeaders).has('content-type')) {\n                {\n                    // eslint-disable-next-line no-console\n                    console.warn('Request was created with header \"content-type\", converted to \"Content-Type\" instead.');\n                }\n                request.headers.set('Content-Type', new Headers(parsedDefaultHeaders).get('content-type'));\n            }\n            else if (body !== undefined && isJSON(body)) {\n                request.headers.set('Content-Type', 'application/json');\n            }\n        }\n        setDefaultHeaders(request.headers, parsedDefaultHeaders);\n        if (body instanceof Blob && body.type) {\n            // work around bug in IE & Edge where the Blob type is ignored in the request\n            // https://connect.microsoft.com/IE/feedback/details/2136163\n            request.headers.set('Content-Type', body.type);\n        }\n        return request;\n    }\n    /**\n     * Calls fetch as a GET request.\n     *\n     * @param input - The resource that you wish to fetch. Either a\n     * Request object, or a string containing the URL of the resource.\n     * @param init - An options object containing settings to be applied to\n     * the Request.\n     * @returns A Promise for the Response from the fetch request.\n     */\n    get(input, init) {\n        return this.fetch(input, init);\n    }\n    /**\n     * Calls fetch with request method set to POST.\n     *\n     * @param input - The resource that you wish to fetch. Either a\n     * Request object, or a string containing the URL of the resource.\n     * @param body - The body of the request.\n     * @param init - An options object containing settings to be applied to\n     * the Request.\n     * @returns A Promise for the Response from the fetch request.\n     */\n    post(input, body, init) {\n        return this._callFetch(input, body, init, 'POST');\n    }\n    /**\n     * Calls fetch with request method set to PUT.\n     *\n     * @param input - The resource that you wish to fetch. Either a\n     * Request object, or a string containing the URL of the resource.\n     * @param body - The body of the request.\n     * @param init - An options object containing settings to be applied to\n     * the Request.\n     * @returns A Promise for the Response from the fetch request.\n     */\n    put(input, body, init) {\n        return this._callFetch(input, body, init, 'PUT');\n    }\n    /**\n     * Calls fetch with request method set to PATCH.\n     *\n     * @param input - The resource that you wish to fetch. Either a\n     * Request object, or a string containing the URL of the resource.\n     * @param body - The body of the request.\n     * @param init - An options object containing settings to be applied to\n     * the Request.\n     * @returns A Promise for the Response from the fetch request.\n     */\n    patch(input, body, init) {\n        return this._callFetch(input, body, init, 'PATCH');\n    }\n    /**\n     * Calls fetch with request method set to DELETE.\n     *\n     * @param input - The resource that you wish to fetch. Either a\n     * Request object, or a string containing the URL of the resource.\n     * @param body - The body of the request.\n     * @param init - An options object containing settings to be applied to\n     * the Request.\n     * @returns A Promise for the Response from the fetch request.\n     */\n    delete(input, body, init) {\n        return this._callFetch(input, body, init, 'DELETE');\n    }\n    /**\n     * Dispose and cleanup used resources of this client.\n     */\n    dispose() {\n        this._interceptors.forEach(i => i.dispose?.());\n        this._interceptors.length = 0;\n        this._dispatcher = null;\n    }\n    /** @internal */\n    _trackRequestStart() {\n        this.isRequesting = !!(++this.activeRequestCount);\n        if (this.isRequesting && this._dispatcher != null) {\n            dispatch(this._dispatcher, HttpClientEvent.started);\n        }\n    }\n    /** @internal */\n    _trackRequestEnd() {\n        this.isRequesting = !!(--this.activeRequestCount);\n        if (!this.isRequesting && this._dispatcher != null) {\n            dispatch(this._dispatcher, HttpClientEvent.drained);\n        }\n    }\n    processRequest(request, interceptors) {\n        return this._applyInterceptors(request, interceptors, 'request', 'requestError', Request, this);\n    }\n    processResponse(response, interceptors, request) {\n        return this._applyInterceptors(response, interceptors, 'response', 'responseError', Response, request, this);\n    }\n    /** @internal */\n    _applyInterceptors(input, interceptors, successName, errorName, Type, ...interceptorArgs) {\n        return (interceptors ?? [])\n            .reduce((chain, interceptor) => {\n            const successHandler = interceptor[successName];\n            const errorHandler = interceptor[errorName];\n            return chain.then(successHandler ? (value => value instanceof Type ? successHandler.call(interceptor, value, ...interceptorArgs) : value) : identity, errorHandler ? (reason => errorHandler.call(interceptor, reason, ...interceptorArgs)) : thrower);\n        }, Promise.resolve(input));\n    }\n    /** @internal */\n    _callFetch(input, body, init, method) {\n        if (!init) {\n            init = {};\n        }\n        init.method = method;\n        if (body != null) {\n            init.body = body;\n        }\n        return this.fetch(input, init);\n    }\n}\nfunction parseHeaderValues(headers) {\n    const parsedHeaders = {};\n    const $headers = headers ?? {};\n    for (const name of Object.keys($headers)) {\n        parsedHeaders[name] = (typeof $headers[name] === 'function')\n            ? $headers[name]()\n            : $headers[name];\n    }\n    return parsedHeaders;\n}\nfunction getRequestUrl(baseUrl, url) {\n    if (absoluteUrlRegexp.test(url)) {\n        return url;\n    }\n    return (baseUrl ?? '') + url;\n}\nfunction setDefaultHeaders(headers, defaultHeaders) {\n    const $defaultHeaders = defaultHeaders ?? {};\n    for (const name of Object.keys($defaultHeaders)) {\n        if (!headers.has(name)) {\n            headers.set(name, $defaultHeaders[name]);\n        }\n    }\n}\nfunction isJSON(str) {\n    try {\n        JSON.parse(str);\n    }\n    catch (err) {\n        return false;\n    }\n    return true;\n}\nfunction identity(x) {\n    return x;\n}\nfunction thrower(x) {\n    throw x;\n}\nfunction dispatch(node, name) {\n    const evt = new node.ownerDocument.defaultView.CustomEvent(name, { bubbles: true, cancelable: true });\n    setTimeout(() => { node.dispatchEvent(evt); }, 1);\n}\n/**\n * A lookup containing events used by HttpClient.\n */\nconst HttpClientEvent = /*@__PURE__*/ Object.freeze({\n    /**\n     * Event to be triggered when a request is sent.\n     */\n    started: 'aurelia-fetch-client-request-started',\n    /**\n     * Event to be triggered when a request is completed.\n     */\n    drained: 'aurelia-fetch-client-requests-drained'\n});\n\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nconst ICacheService = /*@__PURE__*/ DI.createInterface(x => x.singleton(CacheService));\n/**\n * Events that are published by the CacheService\n */\nconst CacheEvent = /*@__PURE__*/ Object.freeze({\n    Set: 'au:fetch:cache:set',\n    Get: 'au:fetch:cache:get',\n    Clear: 'au:fetch:cache:clear',\n    Reset: 'au:fetch:cache:reset',\n    Dispose: 'au:fetch:cache:dispose',\n    CacheHit: 'au:fetch:cache:hit',\n    CacheMiss: 'au:fetch:cache:miss',\n    CacheStale: 'au:fetch:cache:stale',\n    CacheStaleRefreshed: 'au:fetch:cache:stale:refreshed',\n    CacheExpired: 'au:fetch:cache:expired',\n    CacheBackgroundRefreshed: 'au:fetch:cache:background:refreshed',\n    CacheBackgroundRefreshing: 'au:fetch:cache:background:refreshing',\n    CacheBackgroundStopped: 'au:fetch:cache:background:stopped',\n});\n/**\n * A service that can be used to cache data\n */\nclass CacheService {\n    constructor() {\n        this.storage = resolve(ICacheStorage);\n        /** @internal */ this._platform = resolve(IPlatform);\n        /** @internal */ this.ea = resolve(IEventAggregator);\n        /** @internal */ this._httpClient = resolve(IHttpClient);\n        /** @internal */ this._subscribedEvents = [];\n        /** @internal */ this._interval = -1;\n        /** @internal */ this._timeouts = [];\n        /** @internal */ this._requestMap = new Map();\n    }\n    subscribe(event, callback) {\n        const sub = this.ea.subscribe(event, callback);\n        this._subscribedEvents.push(sub);\n        return sub;\n    }\n    subscribeOnce(event, callback) {\n        const sub = this.ea.subscribeOnce(event, callback);\n        this._subscribedEvents.push(sub);\n        return sub;\n    }\n    setStaleTimer(key, staleTime, request) {\n        const timeoutId = this._platform.setTimeout(async () => {\n            this.delete(key);\n            await this._httpClient.get(request);\n            const value = this.getItem(key);\n            this.ea.publish(CacheEvent.CacheStaleRefreshed, { key, value });\n            this._clearTimeout(timeoutId);\n        }, staleTime);\n        this._timeouts.push(timeoutId);\n    }\n    startBackgroundRefresh(timer) {\n        if (!timer || this._interval > -1)\n            return;\n        this._interval = this._platform.setInterval(() => {\n            this.ea.publish(CacheEvent.CacheBackgroundRefreshing);\n            this._requestMap.forEach((req, key) => {\n                this.delete(key);\n                void this._httpClient.get(req).then(() => {\n                    const value = this.getItem(key);\n                    this.ea.publish(CacheEvent.CacheBackgroundRefreshed, { key, value });\n                });\n            });\n        }, timer);\n    }\n    stopBackgroundRefresh() {\n        this._platform.clearInterval(this._interval);\n        this._interval = -1;\n        this.ea.publish(CacheEvent.CacheBackgroundStopped);\n    }\n    set(key, value, options, request) {\n        const cacheItem = {\n            data: value,\n            ...options\n        };\n        this.setItem(key, cacheItem, request);\n    }\n    get(key) {\n        return this.getItem(key)?.data;\n    }\n    setItem(key, value, request) {\n        value.lastCached = Date.now();\n        this.storage.set(key, value);\n        this._requestMap.set(key, request);\n        this.ea.publish(CacheEvent.Set, { key, value });\n    }\n    /**\n     * Tries to retrieve the item from the storage\n     */\n    getItem(key) {\n        if (!this.storage.has(key)) {\n            this.ea.publish(CacheEvent.CacheMiss, { key });\n            return;\n        }\n        const value = this.storage.get(key);\n        if (!value?.staleTime || !value?.lastCached) {\n            this.ea.publish(CacheEvent.CacheHit, { key, value });\n            return value;\n        }\n        const now = Date.now();\n        if (now > value.lastCached + (value.staleTime ?? 0)) {\n            this.ea.publish(CacheEvent.CacheStale, { key, value });\n            return;\n        }\n        if (now > value.lastCached + (value.cacheTime ?? 0)) {\n            this.ea.publish(CacheEvent.CacheExpired, { key, value });\n            return;\n        }\n        this.ea.publish(CacheEvent.CacheHit, { key, value });\n        return value;\n    }\n    delete(key) {\n        this.storage.delete(key);\n        this.ea.publish(CacheEvent.Clear, { key });\n    }\n    clear() {\n        this.storage.clear();\n        this._requestMap.clear();\n        this.ea.publish(CacheEvent.Reset);\n        this.stopBackgroundRefresh();\n        this._timeouts.forEach(x => {\n            this._platform.clearTimeout(x);\n        });\n        this._timeouts.length = 0;\n    }\n    dispose() {\n        this.clear();\n        this._subscribedEvents.forEach(x => x.dispose());\n        this.ea.publish(CacheEvent.Dispose);\n    }\n    /** @internal */\n    _clearTimeout(id) {\n        this._platform.clearTimeout(id);\n        const idx = this._timeouts.indexOf(id);\n        if (idx > -1) {\n            this._timeouts.splice(idx, 1);\n        }\n    }\n}\n\n/** Default configuration which gets spread with overrides */\nconst defaultCacheConfig = {\n    /** 5 minutes */\n    cacheTime: 300_000,\n    /** Always stale */\n    staleTime: 0,\n    refreshStaleImmediate: false,\n    refreshInterval: 0\n};\n/**\n * Interceptor that caches requests on success.\n */\nclass CacheInterceptor {\n    constructor(config) {\n        /** @internal */\n        this._cacheService = resolve(ICacheService);\n        this._config = { ...defaultCacheConfig, ...(config ?? {}) };\n    }\n    request(request) {\n        this._cacheService.startBackgroundRefresh(this._config.refreshInterval);\n        if (request.method !== 'GET')\n            return request;\n        const cacheItem = this._cacheService.get(this.key(request));\n        return this.mark(cacheItem) ?? request;\n    }\n    response(response, request) {\n        if (!request) {\n            return response;\n        }\n        if (response.headers.has(CacheInterceptor.cacheHeader)) {\n            return response;\n        }\n        const key = this.key(request);\n        this._cacheService.setItem(key, {\n            data: response,\n            ...this._config\n        }, request);\n        if (this._config?.refreshStaleImmediate && this._config.staleTime > 0) {\n            this._cacheService.setStaleTimer(key, this._config.staleTime, request);\n        }\n        return response;\n    }\n    dispose() {\n        this._cacheService.stopBackgroundRefresh();\n    }\n    key(request) {\n        return `${CacheInterceptor.prefix}${request.url}`;\n    }\n    mark(response) {\n        response?.headers.set(CacheInterceptor.cacheHeader, 'hit');\n        return response;\n    }\n}\nCacheInterceptor.prefix = 'au:interceptor:';\nCacheInterceptor.cacheHeader = 'x-au-fetch-cache';\n\nclass BrowserIndexDBStorage {\n    constructor() {\n        this.cache = resolve(IPlatform).globalThis.indexedDB;\n        this.getStore = () => this.database.transaction(BrowserIndexDBStorage.cacheName, 'readwrite').objectStore(BrowserIndexDBStorage.cacheName);\n        this.delete = (key) => {\n            const store = this.getStore();\n            store.delete(key);\n        };\n        this.has = (key) => this.getStore().count(key).result > 0;\n        this.set = (key, value) => this.getStore().put(value, key);\n        this.get = (key) => this.getStore().get(key).result;\n        this.clear = () => {\n            const store = this.getStore();\n            store.getAllKeys().result.forEach(key => {\n                store.delete(key);\n            });\n        };\n        this.database = this.cache.open(BrowserIndexDBStorage.cacheName).result;\n    }\n}\nBrowserIndexDBStorage.cacheName = 'au-cache';\n\nclass BrowserStorage {\n    constructor(cache) {\n        this.cache = cache;\n        this.delete = (key) => this.cache.removeItem(key);\n        this.has = (key) => Object.keys(this.cache).some(x => x === key);\n        this.set = (key, value) => this.cache.setItem(key, JSON.stringify(value));\n        this.get = (key) => JSON.parse(this.cache.getItem(key) ?? 'null');\n        this.clear = () => {\n            Object.keys(this.cache).forEach(key => {\n                if (!key.startsWith(CacheInterceptor.prefix))\n                    return;\n                this.cache.removeItem(key);\n            });\n        };\n    }\n}\n\n/**\n * A simple browser local storage based storage implementation for cache interceptor\n */\nclass BrowserLocalStorage extends BrowserStorage {\n    constructor() {\n        super(resolve(IPlatform).globalThis.localStorage);\n    }\n}\n\n/**\n * A simple browser session storage based storage implementation for cache interceptor\n */\nclass BrowserSessionStorage extends BrowserStorage {\n    constructor() {\n        super(resolve(IPlatform).globalThis.sessionStorage);\n    }\n}\n\n/**\n * The strategy to use when retrying requests.\n */\nconst RetryStrategy = /*@__PURE__*/ Object.freeze({\n    fixed: 0,\n    incremental: 1,\n    exponential: 2,\n    random: 3\n});\nconst defaultRetryConfig = {\n    maxRetries: 3,\n    interval: 1000,\n    strategy: RetryStrategy.fixed\n};\n/**\n * Interceptor that retries requests on error, based on a given RetryConfiguration.\n */\nclass RetryInterceptor {\n    /**\n     * Creates an instance of RetryInterceptor.\n     */\n    constructor(retryConfig) {\n        /** @internal */\n        this.p = resolve(IPlatform);\n        this.retryConfig = { ...defaultRetryConfig, ...(retryConfig ?? {}) };\n        if (this.retryConfig.strategy === RetryStrategy.exponential\n            && this.retryConfig.interval <= 1000) {\n            throw createMappedError(5007 /* ErrorNames.retry_interceptor_invalid_exponential_interval */, this.retryConfig.interval);\n        }\n    }\n    /**\n     * Called with the request before it is sent. It remembers the request so it can be retried on error.\n     *\n     * @param request - The request to be sent.\n     * @returns The existing request, a new request or a response; or a Promise for any of these.\n     */\n    request(request) {\n        if (!request.retryConfig) {\n            request.retryConfig = { ...this.retryConfig };\n            request.retryConfig.counter = 0;\n        }\n        // do this on every request\n        request.retryConfig.requestClone = request.clone();\n        return request;\n    }\n    /**\n     * Called with the response after it is received. Clears the remembered request, as it was succesfull.\n     *\n     * @param response - The response.\n     * @returns The response; or a Promise for one.\n     */\n    response(response, request) {\n        // retry was successful, so clean up after ourselves\n        delete request.retryConfig;\n        return response;\n    }\n    /**\n     * Handles fetch errors and errors generated by previous interceptors. This\n     * function acts as a Promise rejection handler. It wil retry the remembered request based on the\n     * configured RetryConfiguration.\n     *\n     * @param error - The rejection value from the fetch request or from a\n     * previous interceptor.\n     * @returns The response of the retry; or a Promise for one.\n     */\n    responseError(error, request, httpClient) {\n        const { retryConfig } = request;\n        const { requestClone } = retryConfig;\n        return Promise.resolve().then(() => {\n            if (retryConfig.counter < retryConfig.maxRetries) {\n                const result = retryConfig.doRetry != null ? retryConfig.doRetry(error, request) : true;\n                return Promise.resolve(result).then(doRetry => {\n                    if (doRetry) {\n                        retryConfig.counter++;\n                        const delay = calculateDelay(retryConfig);\n                        return new Promise(resolve => this.p.setTimeout(resolve, !isNaN(delay) ? delay : 0))\n                            .then(() => {\n                            const newRequest = requestClone.clone();\n                            if (typeof (retryConfig.beforeRetry) === 'function') {\n                                return retryConfig.beforeRetry(newRequest, httpClient);\n                            }\n                            return newRequest;\n                        })\n                            .then(newRequest => {\n                            const retryableRequest = { ...newRequest, retryConfig };\n                            return httpClient.fetch(retryableRequest);\n                        });\n                    }\n                    // no more retries, so clean up\n                    delete request.retryConfig;\n                    throw error;\n                });\n            }\n            // no more retries, so clean up\n            delete request.retryConfig;\n            throw error;\n        });\n    }\n}\nfunction calculateDelay(retryConfig) {\n    const { interval, strategy, minRandomInterval, maxRandomInterval, counter } = retryConfig;\n    if (typeof (strategy) === 'function') {\n        return retryConfig.strategy(counter);\n    }\n    switch (strategy) {\n        case (RetryStrategy.fixed):\n            return retryStrategies[RetryStrategy.fixed](interval);\n        case (RetryStrategy.incremental):\n            return retryStrategies[RetryStrategy.incremental](counter, interval);\n        case (RetryStrategy.exponential):\n            return retryStrategies[RetryStrategy.exponential](counter, interval);\n        case (RetryStrategy.random):\n            return retryStrategies[RetryStrategy.random](counter, interval, minRandomInterval, maxRandomInterval);\n        default:\n            throw createMappedError(5008 /* ErrorNames.retry_interceptor_invalid_strategy */, strategy);\n    }\n}\nconst retryStrategies = [\n    // fixed\n    interval => interval,\n    // incremental\n    (retryCount, interval) => interval * retryCount,\n    // exponential\n    (retryCount, interval) => retryCount === 1 ? interval : interval ** retryCount / 1000,\n    // random\n    (retryCount, interval, minRandomInterval = 0, maxRandomInterval = 60000) => {\n        return Math.random() * (maxRandomInterval - minRandomInterval) + minRandomInterval;\n    }\n];\n\nexport { BrowserIndexDBStorage, BrowserLocalStorage, BrowserSessionStorage, CacheEvent, CacheInterceptor, CacheService, HttpClient, HttpClientConfiguration, HttpClientEvent, ICacheService, ICacheStorage, IFetchFn, IHttpClient, MemoryStorage, RetryInterceptor, RetryStrategy, json };\n//# sourceMappingURL=index.dev.mjs.map\n"],"names":["json","body","replacer","HttpClientConfiguration","resolve","IContainer","baseUrl","defaults","interceptor","standardConfig","rejectOnError","config","RetryInterceptor","dispatcher","response","createMappedError","code","details","getMessageByCode","errorsMap","name","cooked","i","regex","matches","method","_a","value","absoluteUrlRegexp","IFetchFn","DI","x","IHttpClient","HttpClient","factory","normalizedConfig","c","interceptors","retryInterceptorIndex","input","init","request","result","error","requestContentType","parsedDefaultHeaders","parseHeaderValues","requestInit","getRequestUrl","isJSON","setDefaultHeaders","dispatch","HttpClientEvent","successName","errorName","Type","interceptorArgs","chain","successHandler","errorHandler","identity","reason","thrower","headers","parsedHeaders","$headers","url","defaultHeaders","$defaultHeaders","str","node","evt","RetryStrategy","defaultRetryConfig","retryConfig","IPlatform","httpClient","requestClone","doRetry","delay","calculateDelay","newRequest","retryableRequest","interval","strategy","minRandomInterval","maxRandomInterval","counter","retryStrategies","retryCount"],"mappings":"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","x_google_ignoreList":[0]}