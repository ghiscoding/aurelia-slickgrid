{"version":3,"file":"aggregators.index-6uBa5zAH.js","sources":["../../../../node_modules/.pnpm/@slickgrid-universal+common@5.13.3/node_modules/@slickgrid-universal/common/dist/esm/aggregators/sumAggregator.js","../../../../node_modules/.pnpm/@slickgrid-universal+common@5.13.3/node_modules/@slickgrid-universal/common/dist/esm/aggregators/avgAggregator.js","../../../../node_modules/.pnpm/@slickgrid-universal+common@5.13.3/node_modules/@slickgrid-universal/common/dist/esm/aggregators/aggregators.index.js"],"sourcesContent":["import { isNumber } from '@slickgrid-universal/utils';\nexport class SumAggregator {\n    constructor(field) {\n        this._isInitialized = false;\n        this._isTreeAggregator = false;\n        this._sum = 0;\n        this._itemCount = 0;\n        this._type = 'sum';\n        this._field = field;\n    }\n    get field() {\n        return this._field;\n    }\n    get isInitialized() {\n        return this._isInitialized;\n    }\n    get type() {\n        return this._type;\n    }\n    init(item, isTreeAggregator = false) {\n        this._isTreeAggregator = isTreeAggregator;\n        this._isInitialized = true;\n        this._sum = 0;\n        this._itemCount = 0;\n        // when dealing with Tree Data structure, we also need to keep sum & itemCount refs\n        if (isTreeAggregator) {\n            if (!item.__treeTotals) {\n                item.__treeTotals = {};\n            }\n            if (item.__treeTotals[this._type] === undefined) {\n                item.__treeTotals[this._type] = {};\n                item.__treeTotals.count = {};\n            }\n            item.__treeTotals['count'][this._field] = 0;\n            item.__treeTotals[this._type][this._field] = 0;\n        }\n    }\n    accumulate(item, isTreeParent = false) {\n        const val = item?.hasOwnProperty(this._field) ? item[this._field] : null;\n        // when dealing with Tree Data structure, we need keep only the new sum (without doing any addition)\n        if (!this._isTreeAggregator) {\n            // not a Tree structure, we'll do a regular summation\n            if (isNumber(val)) {\n                this._sum += parseFloat(val);\n            }\n        }\n        else {\n            if (isTreeParent) {\n                if (!item.__treeTotals) {\n                    item.__treeTotals = {};\n                }\n                this.addGroupTotalPropertiesWhenNotExist(item.__treeTotals);\n                this._sum = parseFloat(item.__treeTotals[this._type][this._field] ?? 0);\n                this._itemCount = item.__treeTotals['count'][this._field] ?? 0;\n            }\n            else if (isNumber(val)) {\n                this._sum = parseFloat(val);\n                this._itemCount = 1;\n            }\n        }\n    }\n    storeResult(groupTotals) {\n        if (!groupTotals || groupTotals[this._type] === undefined) {\n            groupTotals[this._type] = {};\n        }\n        this.addGroupTotalPropertiesWhenNotExist(groupTotals);\n        let sum = this._sum;\n        let itemCount = this._itemCount;\n        // when dealing with Tree Data, we also need to take the parent's total and add it to the final sum\n        if (this._isTreeAggregator) {\n            sum += groupTotals[this._type][this._field];\n            itemCount += groupTotals['count'][this._field];\n            groupTotals['count'][this._field] = itemCount;\n        }\n        groupTotals[this._type][this._field] = sum;\n    }\n    addGroupTotalPropertiesWhenNotExist(groupTotals) {\n        if (groupTotals[this._type] === undefined) {\n            groupTotals[this._type] = {};\n        }\n        if (this._isTreeAggregator && groupTotals['count'] === undefined) {\n            groupTotals['count'] = {};\n        }\n    }\n}\n//# sourceMappingURL=sumAggregator.js.map","import { isNumber } from '@slickgrid-universal/utils';\nexport class AvgAggregator {\n    constructor(field) {\n        this._isInitialized = false;\n        this._isTreeAggregator = false;\n        this._nonNullCount = 0;\n        this._sum = 0;\n        this._type = 'avg';\n        this._field = field;\n    }\n    get field() {\n        return this._field;\n    }\n    get isInitialized() {\n        return this._isInitialized;\n    }\n    get type() {\n        return this._type;\n    }\n    init(item, isTreeAggregator = false) {\n        this._sum = 0;\n        this._nonNullCount = 0;\n        this._isInitialized = true;\n        // when dealing with Tree Data structure, we also need to keep sum & itemCount refs\n        // also while calculating Avg Aggregator, we could in theory skip completely SumAggregator because we kept the sum already for calculations\n        this._isTreeAggregator = isTreeAggregator;\n        if (isTreeAggregator) {\n            if (!item.__treeTotals) {\n                item.__treeTotals = {};\n            }\n            if (item.__treeTotals[this._type] === undefined) {\n                item.__treeTotals[this._type] = {};\n                item.__treeTotals.sum = {};\n                item.__treeTotals.count = {};\n            }\n            item.__treeTotals[this._type][this._field] = 0;\n            item.__treeTotals['count'][this._field] = 0;\n            item.__treeTotals['sum'][this._field] = 0;\n        }\n    }\n    accumulate(item, isTreeParent = false) {\n        const val = item?.hasOwnProperty(this._field) ? item[this._field] : null;\n        // when dealing with Tree Data structure, we need keep only the new sum (without doing any addition)\n        if (!this._isTreeAggregator) {\n            // not a Tree structure, we'll do a regular summation\n            if (isNumber(val)) {\n                this._nonNullCount++;\n                this._sum += parseFloat(val);\n            }\n        }\n        else {\n            if (isTreeParent) {\n                if (!item.__treeTotals) {\n                    item.__treeTotals = {};\n                }\n                this.addGroupTotalPropertiesWhenNotExist(item.__treeTotals);\n                this._sum = parseFloat(item.__treeTotals['sum'][this._field] ?? 0);\n                this._nonNullCount = item.__treeTotals['count'][this._field] ?? 0;\n            }\n            else if (isNumber(val)) {\n                this._sum = parseFloat(val);\n                this._nonNullCount = 1;\n            }\n        }\n    }\n    storeResult(groupTotals) {\n        let sum = this._sum;\n        let itemCount = this._nonNullCount;\n        this.addGroupTotalPropertiesWhenNotExist(groupTotals);\n        // when dealing with Tree Data, we also need to take the parent's total and add it to the final sum\n        if (this._isTreeAggregator) {\n            sum += groupTotals['sum'][this._field];\n            itemCount += groupTotals['count'][this._field];\n            groupTotals['sum'][this._field] = sum;\n            groupTotals['count'][this._field] = itemCount;\n        }\n        if (itemCount !== 0) {\n            groupTotals[this._type][this._field] = itemCount === 0 ? sum : sum / itemCount;\n        }\n    }\n    addGroupTotalPropertiesWhenNotExist(groupTotals) {\n        if (groupTotals[this._type] === undefined) {\n            groupTotals[this._type] = {};\n        }\n        if (this._isTreeAggregator && groupTotals['sum'] === undefined) {\n            groupTotals['sum'] = {};\n        }\n        if (this._isTreeAggregator && groupTotals['count'] === undefined) {\n            groupTotals['count'] = {};\n        }\n    }\n}\n//# sourceMappingURL=avgAggregator.js.map","import { AvgAggregator } from './avgAggregator.js';\nimport { CloneAggregator } from './cloneAggregator.js';\nimport { CountAggregator } from './countAggregator.js';\nimport { DistinctAggregator } from './distinctAggregator.js';\nimport { MinAggregator } from './minAggregator.js';\nimport { MaxAggregator } from './maxAggregator.js';\nimport { SumAggregator } from './sumAggregator.js';\n/** Provides a list of different Aggregators for the Group Formatter */\nexport const Aggregators = {\n    /** Average Aggregator which calculate the average of a given group */\n    Avg: AvgAggregator,\n    /** Clone Aggregator will simply clone (copy) over the last defined value of a given group */\n    Clone: CloneAggregator,\n    /** Count Aggregator will count the number of rows in the group */\n    Count: CountAggregator,\n    /** Distinct Aggregator will return an array of distinct values found inside the given group */\n    Distinct: DistinctAggregator,\n    /** Minimum Aggregator which will find the minimum value inside the given group */\n    Min: MinAggregator,\n    /** Maximum Aggregator which will find the maximum value inside the given group */\n    Max: MaxAggregator,\n    /** Sum Aggregator which calculate the sum of a given group */\n    Sum: SumAggregator,\n};\n//# sourceMappingURL=aggregators.index.js.map"],"names":["SumAggregator","field","item","isTreeAggregator","isTreeParent","val","isNumber","groupTotals","sum","itemCount","AvgAggregator","Aggregators"],"mappings":"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","x_google_ignoreList":[0,1,2]}