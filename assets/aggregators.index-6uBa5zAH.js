import{M as i}from"./index-Bz3uuwsZ.js";class h{constructor(t){this._isInitialized=!1,this._isTreeAggregator=!1,this._sum=0,this._itemCount=0,this._type="sum",this._field=t}get field(){return this._field}get isInitialized(){return this._isInitialized}get type(){return this._type}init(t,s=!1){this._isTreeAggregator=s,this._isInitialized=!0,this._sum=0,this._itemCount=0,s&&(t.__treeTotals||(t.__treeTotals={}),t.__treeTotals[this._type]===void 0&&(t.__treeTotals[this._type]={},t.__treeTotals.count={}),t.__treeTotals.count[this._field]=0,t.__treeTotals[this._type][this._field]=0)}accumulate(t,s=!1){const e=t!=null&&t.hasOwnProperty(this._field)?t[this._field]:null;this._isTreeAggregator?s?(t.__treeTotals||(t.__treeTotals={}),this.addGroupTotalPropertiesWhenNotExist(t.__treeTotals),this._sum=parseFloat(t.__treeTotals[this._type][this._field]??0),this._itemCount=t.__treeTotals.count[this._field]??0):i(e)&&(this._sum=parseFloat(e),this._itemCount=1):i(e)&&(this._sum+=parseFloat(e))}storeResult(t){(!t||t[this._type]===void 0)&&(t[this._type]={}),this.addGroupTotalPropertiesWhenNotExist(t);let s=this._sum,e=this._itemCount;this._isTreeAggregator&&(s+=t[this._type][this._field],e+=t.count[this._field],t.count[this._field]=e),t[this._type][this._field]=s}addGroupTotalPropertiesWhenNotExist(t){t[this._type]===void 0&&(t[this._type]={}),this._isTreeAggregator&&t.count===void 0&&(t.count={})}}class l{constructor(t){this._isInitialized=!1,this._isTreeAggregator=!1,this._nonNullCount=0,this._sum=0,this._type="avg",this._field=t}get field(){return this._field}get isInitialized(){return this._isInitialized}get type(){return this._type}init(t,s=!1){this._sum=0,this._nonNullCount=0,this._isInitialized=!0,this._isTreeAggregator=s,s&&(t.__treeTotals||(t.__treeTotals={}),t.__treeTotals[this._type]===void 0&&(t.__treeTotals[this._type]={},t.__treeTotals.sum={},t.__treeTotals.count={}),t.__treeTotals[this._type][this._field]=0,t.__treeTotals.count[this._field]=0,t.__treeTotals.sum[this._field]=0)}accumulate(t,s=!1){const e=t!=null&&t.hasOwnProperty(this._field)?t[this._field]:null;this._isTreeAggregator?s?(t.__treeTotals||(t.__treeTotals={}),this.addGroupTotalPropertiesWhenNotExist(t.__treeTotals),this._sum=parseFloat(t.__treeTotals.sum[this._field]??0),this._nonNullCount=t.__treeTotals.count[this._field]??0):i(e)&&(this._sum=parseFloat(e),this._nonNullCount=1):i(e)&&(this._nonNullCount++,this._sum+=parseFloat(e))}storeResult(t){let s=this._sum,e=this._nonNullCount;this.addGroupTotalPropertiesWhenNotExist(t),this._isTreeAggregator&&(s+=t.sum[this._field],e+=t.count[this._field],t.sum[this._field]=s,t.count[this._field]=e),e!==0&&(t[this._type][this._field]=e===0?s:s/e)}addGroupTotalPropertiesWhenNotExist(t){t[this._type]===void 0&&(t[this._type]={}),this._isTreeAggregator&&t.sum===void 0&&(t.sum={}),this._isTreeAggregator&&t.count===void 0&&(t.count={})}}const n={Avg:l,Sum:h};export{n as A};
//# sourceMappingURL=aggregators.index-6uBa5zAH.js.map
