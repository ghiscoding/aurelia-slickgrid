{"version":3,"file":"graphql.service-B0y6nIZw.js","sources":["../../../../node_modules/.pnpm/@slickgrid-universal+graphql@5.13.3/node_modules/@slickgrid-universal/graphql/dist/esm/services/graphqlQueryBuilder.js","../../../../node_modules/.pnpm/@slickgrid-universal+graphql@5.13.3/node_modules/@slickgrid-universal/graphql/dist/esm/services/graphql.service.js"],"sourcesContent":["/**\n * This GraphqlQueryBuilder class is a lib that already existed\n * but was causing issues with TypeScript, RequireJS and other bundler/packagers,\n * so I simply rewrote the code in TypeScript to make it easier to import.\n *\n * The previous lib can be found here at this Github link:\n *     https://github.com/codemeasandwich/graphql-query-builder\n * With an MIT licence that and can be found at\n *     https://github.com/codemeasandwich/graphql-query-builder/blob/master/LICENSE\n */\nexport default class GraphqlQueryBuilder {\n    /* Constructor, query/mutator you wish to use, and an alias or filter arguments. */\n    constructor(queryFnName, aliasOrFilter) {\n        this.queryFnName = queryFnName;\n        this.head = [];\n        if (typeof aliasOrFilter === 'string') {\n            this.alias = aliasOrFilter;\n        }\n        else if (typeof aliasOrFilter === 'object') {\n            this.filter(aliasOrFilter);\n        }\n        else if (aliasOrFilter === undefined && arguments.length === 2) {\n            throw new TypeError(`You have passed undefined as Second argument to \"Query\"`);\n        }\n        else if (aliasOrFilter !== undefined) {\n            throw new TypeError(`Second argument to \"Query\" should be an alias name(String) or filter arguments(Object). What was passed is: ${aliasOrFilter}`);\n        }\n    }\n    /**\n     * The parameters to run the query against.\n     * @param filters An object mapping attribute to values\n     */\n    filter(filters) {\n        for (const prop of Object.keys(filters)) {\n            if (typeof filters[prop] === 'function') {\n                continue;\n            }\n            const val = this.getGraphQLValue(filters[prop]);\n            if (val === '{}') {\n                continue;\n            }\n            this.head.push(`${prop}:${val}`);\n        }\n        return this;\n    }\n    /**\n     * Outlines the properties you wish to be returned from the query.\n     * @param properties representing each attribute you want Returned\n     */\n    find(...searches) {\n        // THIS NEED TO BE A \"FUNCTION\" to scope 'arguments'\n        if (!searches || !Array.isArray(searches) || searches.length === 0) {\n            throw new TypeError(`find value can not be >>falsy<<`);\n        }\n        // if its a string.. it may have other values\n        // else it sould be an Object or Array of maped values\n        const searchKeys = searches.length === 1 && Array.isArray(searches[0]) ? searches[0] : searches;\n        this.body = this.parceFind(searchKeys);\n        return this;\n    }\n    /**\n     * set an alias for this result.\n     * @param alias\n     */\n    setAlias(alias) {\n        this.alias = alias;\n    }\n    /**\n     * Return to the formatted query string\n     * @return\n     */\n    toString() {\n        if (this.body === undefined) {\n            throw new ReferenceError(`return properties are not defined. use the 'find' function to defined them`);\n        }\n        return `${this.alias ? this.alias + ':' : ''} ${this.queryFnName} ${this.head.length > 0 ? '(' + this.head.join(',') + ')' : ''}  { ${this.body} }`;\n    }\n    // --\n    // protected functions\n    // --------------------\n    parceFind(_levelA) {\n        const propsA = _levelA.map((_currentValue, index) => {\n            const itemX = _levelA[index];\n            if (itemX instanceof GraphqlQueryBuilder) {\n                return itemX.toString();\n            }\n            else if (!Array.isArray(itemX) && typeof itemX === 'object') {\n                const propsAA = Object.keys(itemX);\n                if (1 !== propsAA.length) {\n                    throw new RangeError(`Alias objects should only have one value. was passed: ${JSON.stringify(itemX)}`);\n                }\n                const propS = propsAA[0];\n                const item = itemX[propS];\n                if (Array.isArray(item)) {\n                    return new GraphqlQueryBuilder(propS).find(item);\n                }\n                return `${propS} : ${item} `;\n            }\n            else if (typeof itemX === 'string') {\n                return itemX;\n            }\n            else {\n                throw new RangeError(`cannot handle Find value of ${itemX}`);\n            }\n        });\n        return propsA.join(',');\n    }\n    getGraphQLValue(value) {\n        if (typeof value === 'string') {\n            value = JSON.stringify(value);\n        }\n        else if (Array.isArray(value)) {\n            value = value\n                .map((item) => {\n                return this.getGraphQLValue(item);\n            })\n                .join();\n            value = `[${value}]`;\n        }\n        else if (value instanceof Date) {\n            value = JSON.stringify(value);\n        }\n        else if (value !== null && typeof value === 'object') {\n            value = this.objectToString(value);\n        }\n        return value;\n    }\n    objectToString(obj) {\n        const sourceA = [];\n        for (const prop of Object.keys(obj)) {\n            if (typeof obj[prop] === 'function') {\n                continue;\n            }\n            sourceA.push(`${prop}:${this.getGraphQLValue(obj[prop])}`);\n        }\n        return `{${sourceA.join()}}`;\n    }\n}\n//# sourceMappingURL=graphqlQueryBuilder.js.map","import { FieldType, mapOperatorType, mapOperatorByFieldType, OperatorType, SortDirection } from '@slickgrid-universal/common';\nimport { getHtmlStringOutput, stripTags } from '@slickgrid-universal/utils';\nimport QueryBuilder from './graphqlQueryBuilder.js';\nconst DEFAULT_ITEMS_PER_PAGE = 25;\nconst DEFAULT_PAGE_SIZE = 20;\nexport class GraphqlService {\n    constructor() {\n        this._currentFilters = [];\n        this._currentPagination = null;\n        this._currentSorters = [];\n        this._datasetIdPropName = 'id';\n        this.defaultPaginationOptions = {\n            first: DEFAULT_ITEMS_PER_PAGE,\n            offset: 0,\n        };\n    }\n    /** Getter for the Column Definitions */\n    get columnDefinitions() {\n        return this._columnDefinitions;\n    }\n    /** Getter for the Grid Options pulled through the Grid Object */\n    get _gridOptions() {\n        return this._grid?.getOptions() ?? {};\n    }\n    /** Initialization of the service, which acts as a constructor */\n    init(serviceOptions, pagination, grid, sharedService) {\n        this._grid = grid;\n        this.options = serviceOptions || { datasetName: '' };\n        this.pagination = pagination;\n        this._datasetIdPropName = this._gridOptions.datasetIdPropertyName || 'id';\n        if (typeof grid?.getColumns === 'function') {\n            this._columnDefinitions = sharedService?.allColumns ?? grid.getColumns() ?? [];\n        }\n    }\n    /**\n     * Build the GraphQL query, since the service include/exclude cursor, the output query will be different.\n     * @param serviceOptions GraphqlServiceOption\n     */\n    buildQuery() {\n        if (!this.options || !this.options.datasetName || !Array.isArray(this._columnDefinitions)) {\n            throw new Error('GraphQL Service requires the \"datasetName\" property to properly build the GraphQL query');\n        }\n        // get the column definitions and exclude some if they were tagged as excluded\n        let columnDefinitions = this._columnDefinitions || [];\n        columnDefinitions = columnDefinitions.filter((column) => !column.excludeFromQuery);\n        const queryQb = new QueryBuilder(`query ${this.options.operationName ?? ''}`);\n        const datasetQb = new QueryBuilder(this.options.datasetName);\n        const nodesQb = new QueryBuilder('nodes');\n        // get all the columnds Ids for the filters to work\n        const columnIds = [];\n        if (Array.isArray(columnDefinitions)) {\n            for (const column of columnDefinitions) {\n                if (!column.excludeFieldFromQuery) {\n                    columnIds.push(column.field);\n                }\n                // when extra \"fields\" are provided, also push them to columnIds\n                if (column.fields) {\n                    columnIds.push(...column.fields);\n                }\n            }\n        }\n        // Slickgrid also requires the \"id\" field to be part of DataView\n        // add it to the GraphQL query if it wasn't already part of the list\n        if (columnIds.indexOf(this._datasetIdPropName) === -1) {\n            columnIds.unshift(this._datasetIdPropName);\n        }\n        const columnsQuery = this.buildFilterQuery(columnIds);\n        let graphqlNodeFields = [];\n        if (this._gridOptions.enablePagination !== false || this.options.infiniteScroll) {\n            if (this.options.useCursor) {\n                // ...pageInfo { hasNextPage, endCursor }, edges { cursor, node { _columns_ } }, totalCount: 100\n                const edgesQb = new QueryBuilder('edges');\n                const pageInfoQb = new QueryBuilder('pageInfo');\n                pageInfoQb.find('hasNextPage', 'hasPreviousPage', 'endCursor', 'startCursor');\n                nodesQb.find(columnsQuery);\n                edgesQb.find(['cursor']);\n                graphqlNodeFields = ['totalCount', nodesQb, pageInfoQb, edgesQb];\n            }\n            else {\n                // ...nodes { _columns_ }, totalCount: 100\n                nodesQb.find(columnsQuery);\n                graphqlNodeFields = ['totalCount', nodesQb];\n            }\n            // all properties to be returned by the query\n            datasetQb.find(graphqlNodeFields);\n        }\n        else {\n            // include all columns to be returned\n            datasetQb.find(columnsQuery);\n        }\n        // add dataset filters, could be Pagination and SortingFilters and/or FieldFilters\n        let datasetFilters = {};\n        // only add pagination if it's enabled in the grid options\n        if (this._gridOptions.enablePagination !== false || this.options.infiniteScroll) {\n            datasetFilters = {};\n            if (this.options.useCursor && this.options.paginationOptions) {\n                datasetFilters = { ...this.options.paginationOptions };\n            }\n            else {\n                const paginationOptions = this.options?.paginationOptions;\n                datasetFilters.first =\n                    this.options?.infiniteScroll?.fetchSize ??\n                        this.options?.paginationOptions?.first ??\n                        this.pagination?.pageSize ??\n                        this.defaultPaginationOptions.first;\n                datasetFilters.offset = paginationOptions && 'offset' in paginationOptions ? +paginationOptions.offset : 0;\n            }\n        }\n        if (this.options.sortingOptions && Array.isArray(this.options.sortingOptions) && this.options.sortingOptions.length > 0) {\n            // orderBy: [{ field:x, direction: 'ASC' }]\n            datasetFilters.orderBy = this.options.sortingOptions;\n        }\n        if (this.options.filteringOptions && Array.isArray(this.options.filteringOptions) && this.options.filteringOptions.length > 0) {\n            // filterBy: [{ field: date, operator: '>', value: '2000-10-10' }]\n            datasetFilters.filterBy = this.options.filteringOptions;\n        }\n        if (this.options.addLocaleIntoQuery) {\n            // first: 20, ... locale: \"en-CA\"\n            datasetFilters.locale = this._gridOptions.translater?.getCurrentLanguage() || this._gridOptions.locale || 'en';\n        }\n        if (this.options.extraQueryArguments) {\n            // first: 20, ... userId: 123\n            for (const queryArgument of this.options.extraQueryArguments) {\n                datasetFilters[queryArgument.field] = queryArgument.value;\n            }\n        }\n        // with pagination:: query { users(first: 20, offset: 0, orderBy: [], filterBy: []) { totalCount: 100, nodes: { _columns_ }}}\n        // without pagination:: query { users(orderBy: [], filterBy: []) { _columns_ }}\n        datasetQb.filter(datasetFilters);\n        queryQb.find(datasetQb);\n        const enumSearchProperties = ['direction:', 'field:', 'operator:'];\n        return this.trimDoubleQuotesOnEnumField(queryQb.toString(), enumSearchProperties, this.options.keepArgumentFieldDoubleQuotes || false);\n    }\n    postProcess(processResult) {\n        if (processResult.data && this.pagination) {\n            this.pagination.totalItems = processResult.data[this.getDatasetName()]?.totalCount || 0;\n        }\n    }\n    /**\n     * From an input array of strings, we want to build a GraphQL query string.\n     * The process has to take the dot notation and parse it into a valid GraphQL query\n     * Following this SO answer https://stackoverflow.com/a/47705476/1212166\n     *\n     * INPUT::\n     *  ['firstName', 'lastName', 'billing.address.street', 'billing.address.zip']\n     * OUTPUT::\n     * firstName, lastName, billing{address{street, zip}}\n     * @param inputArray\n     */\n    buildFilterQuery(inputArray) {\n        const set = (o = {}, a) => {\n            const k = a.shift();\n            o[k] = a.length ? set(o[k] ?? {}, a) : null;\n            return o;\n        };\n        const output = inputArray.reduce((o, a) => set(o, a.split('.')), {});\n        return JSON.stringify(output)\n            .replace(/\"|:|null/g, '')\n            .replace(/^\\{/, '')\n            .replace(/\\}$/, '');\n    }\n    clearFilters() {\n        this._currentFilters = [];\n        this.updateOptions({ filteringOptions: [] });\n    }\n    clearSorters() {\n        this._currentSorters = [];\n        this.updateOptions({ sortingOptions: [] });\n    }\n    /**\n     * Get default initial Pagination options\n     * @return Pagination Options\n     */\n    getInitPaginationOptions() {\n        const paginationFirst = this.options?.infiniteScroll?.fetchSize ?? this.pagination?.pageSize ?? DEFAULT_ITEMS_PER_PAGE;\n        return this.options?.useCursor ? { first: paginationFirst } : { first: paginationFirst, offset: 0 };\n    }\n    /** Get the GraphQL dataset name */\n    getDatasetName() {\n        return this.options?.datasetName || '';\n    }\n    /** Get the Filters that are currently used by the grid */\n    getCurrentFilters() {\n        return this._currentFilters;\n    }\n    /** Get the Pagination that is currently used by the grid */\n    getCurrentPagination() {\n        return this._currentPagination;\n    }\n    /** Get the Sorters that are currently used by the grid */\n    getCurrentSorters() {\n        return this._currentSorters;\n    }\n    /*\n     * Reset the pagination options\n     */\n    resetPaginationOptions() {\n        let paginationOptions;\n        if (this.options?.useCursor) {\n            paginationOptions = this.getInitPaginationOptions();\n        }\n        else {\n            // first, last, offset\n            paginationOptions = ((this.options && this.options.paginationOptions) || this.getInitPaginationOptions());\n            paginationOptions.offset = 0;\n        }\n        // save current pagination as Page 1 and page size as \"first\" set size\n        this._currentPagination = {\n            pageNumber: 1,\n            pageSize: paginationOptions.first || DEFAULT_PAGE_SIZE,\n        };\n        // unless user specifically set \"enablePagination\" to False, we'll update pagination options in every other cases\n        if (this._gridOptions &&\n            (this._gridOptions.enablePagination || !('enablePagination' in this._gridOptions) || this.options?.infiniteScroll)) {\n            this.updateOptions({ paginationOptions });\n        }\n    }\n    updateOptions(serviceOptions) {\n        this.options = { ...this.options, ...serviceOptions };\n    }\n    /*\n     * FILTERING\n     */\n    processOnFilterChanged(_event, args) {\n        const gridOptions = this._gridOptions;\n        const backendApi = gridOptions.backendServiceApi;\n        if (backendApi === undefined) {\n            throw new Error('Something went wrong in the GraphqlService, \"backendServiceApi\" is not initialized');\n        }\n        // keep current filters & always save it as an array (columnFilters can be an object when it is dealt by SlickGrid Filter)\n        this._currentFilters = this.castFilterToColumnFilters(args.columnFilters);\n        if (!args || !args.grid) {\n            throw new Error('Something went wrong when trying create the GraphQL Backend Service, it seems that \"args\" is not populated correctly');\n        }\n        // loop through all columns to inspect filters & set the query\n        this.updateFilters(args.columnFilters, false);\n        this.resetPaginationOptions();\n        return this.buildQuery();\n    }\n    /*\n     * PAGINATION\n     * With cursor, the query can have 4 arguments (first, after, last, before), for example:\n     *   users (first:20, after:\"YXJyYXljb25uZWN0aW9uOjM=\") {\n     *     totalCount\n     *     pageInfo {\n     *       hasNextPage\n     *       hasPreviousPage\n     *       endCursor\n     *       startCursor\n     *     }\n     *     edges {\n     *       cursor\n     *       node {\n     *         name\n     *         gender\n     *       }\n     *     }\n     *   }\n     * Without cursor, the query can have 3 arguments (first, last, offset), for example:\n     *   users (first:20, offset: 10) {\n     *     totalCount\n     *     nodes {\n     *       name\n     *       gender\n     *     }\n     *   }\n     */\n    processOnPaginationChanged(_event, args) {\n        const pageSize = +(this.options?.infiniteScroll?.fetchSize ||\n            args.pageSize ||\n            (this.pagination ? this.pagination.pageSize : DEFAULT_PAGE_SIZE));\n        // if first/last defined on args, then it is a cursor based pagination change\n        'first' in args || 'last' in args ? this.updatePagination(args.newPage, pageSize, args) : this.updatePagination(args.newPage, pageSize);\n        // build the GraphQL query which we will use in the WebAPI callback\n        return this.buildQuery();\n    }\n    /*\n     * SORTING\n     * we will use sorting as per a Facebook suggestion on a Github issue (with some small changes)\n     * https://github.com/graphql/graphql-relay-js/issues/20#issuecomment-220494222\n     *\n     *  users (first: 20, offset: 10, orderBy: [{field: lastName, direction: ASC}, {field: firstName, direction: DESC}]) {\n     *    totalCount\n     *    nodes {\n     *      name\n     *      gender\n     *    }\n     *  }\n     */\n    processOnSortChanged(_event, args) {\n        const sortColumns = args.multiColumnSort\n            ? args.sortCols\n            : new Array({\n                columnId: args.sortCol?.id ?? '',\n                sortCol: args.sortCol,\n                sortAsc: args.sortAsc,\n            });\n        // loop through all columns to inspect sorters & set the query\n        this.updateSorters(sortColumns);\n        // when using infinite scroll, we need to go back to 1st page\n        if (this.options?.infiniteScroll) {\n            this.updateOptions({ paginationOptions: { offset: 0 } });\n        }\n        // build the GraphQL query which we will use in the WebAPI callback\n        return this.buildQuery();\n    }\n    /**\n     * Update column filters by looping through all columns to inspect filters & update backend service filteringOptions\n     * @param columnFilters\n     */\n    updateFilters(columnFilters, isUpdatedByPresetOrDynamically) {\n        const searchByArray = [];\n        let searchValue;\n        // on filter preset load, we need to keep current filters\n        if (isUpdatedByPresetOrDynamically) {\n            this._currentFilters = this.castFilterToColumnFilters(columnFilters);\n        }\n        for (const columnId in columnFilters) {\n            if (columnId in columnFilters) {\n                const columnFilter = columnFilters[columnId];\n                // if user defined some \"presets\", then we need to find the filters from the column definitions instead\n                let columnDef;\n                if (isUpdatedByPresetOrDynamically && Array.isArray(this._columnDefinitions)) {\n                    columnDef = this._columnDefinitions.find((column) => column.id === columnFilter.columnId);\n                }\n                else {\n                    columnDef = columnFilter.columnDef;\n                }\n                if (!columnDef) {\n                    throw new Error('[GraphQL Service]: Something went wrong in trying to get the column definition of the specified filter (or preset filters). Did you make a typo on the filter columnId?');\n                }\n                let fieldName = columnDef.filter?.queryField || columnDef.queryFieldFilter || columnDef.queryField || columnDef.field || columnDef.name || '';\n                if (fieldName instanceof HTMLElement) {\n                    fieldName = stripTags(fieldName.innerHTML);\n                }\n                const fieldType = columnDef.type || FieldType.string;\n                let searchTerms = columnFilter?.searchTerms ?? [];\n                let fieldSearchValue = Array.isArray(searchTerms) && searchTerms.length === 1 ? searchTerms[0] : '';\n                if (typeof fieldSearchValue === 'undefined') {\n                    fieldSearchValue = '';\n                }\n                if (!fieldName) {\n                    throw new Error(`GraphQL filter could not find the field name to query the search, your column definition must include a valid \"field\" or \"name\" (optionally you can also use the \"queryfield\").`);\n                }\n                if (this.options?.useVerbatimSearchTerms || columnFilter.verbatimSearchTerms) {\n                    searchByArray.push({\n                        field: getHtmlStringOutput(fieldName),\n                        operator: columnFilter.operator,\n                        value: JSON.stringify(columnFilter.searchTerms),\n                    });\n                    continue;\n                }\n                fieldSearchValue = fieldSearchValue === undefined || fieldSearchValue === null ? '' : `${fieldSearchValue}`; // make sure it's a string\n                // run regex to find possible filter operators unless the user disabled the feature\n                const autoParseInputFilterOperator = columnDef.autoParseInputFilterOperator ?? this._gridOptions.autoParseInputFilterOperator;\n                // group (2): comboStartsWith, (3): comboEndsWith, (4): Operator, (1 or 5): searchValue, (6): last char is '*' (meaning starts with, ex.: abc*)\n                const matches = autoParseInputFilterOperator !== false\n                    ? fieldSearchValue.match(/^((.*[^\\\\*\\r\\n])[*]{1}(.*[^*\\r\\n]))|^([<>!=*]{0,2})(.*[^<>!=*])([*]?)$/) || []\n                    : [fieldSearchValue, '', '', '', '', fieldSearchValue, ''];\n                const comboStartsWith = matches?.[2] || '';\n                const comboEndsWith = matches?.[3] || '';\n                let operator = columnFilter.operator || matches?.[4];\n                searchValue = matches?.[1] || matches?.[5] || '';\n                const lastValueChar = matches?.[6] || operator === '*z' || operator === OperatorType.endsWith ? '*' : '';\n                // no need to query if search value is empty\n                if (fieldName && searchValue === '' && searchTerms.length === 0) {\n                    continue;\n                }\n                let filterQueryOverride = undefined;\n                if (typeof this.options?.filterQueryOverride === 'function') {\n                    filterQueryOverride = this.options?.filterQueryOverride({\n                        fieldName: getHtmlStringOutput(fieldName),\n                        columnDef,\n                        operator,\n                        columnFilterOperator: columnFilter.operator,\n                        searchValues: searchTerms,\n                        grid: this._grid,\n                    });\n                }\n                if (filterQueryOverride !== undefined) {\n                    // since this is a Custom Filter, we expect Operator to be a string\n                    // and it is assumed that the developer will implement this custom operator in their GraphQL Schema\n                    // e.g.: https://stackoverflow.com/a/37981802/1212166\n                    searchByArray.push(filterQueryOverride);\n                }\n                else {\n                    if (comboStartsWith && comboEndsWith) {\n                        searchTerms = [comboStartsWith, comboEndsWith];\n                        operator = OperatorType.startsWithEndsWith;\n                    }\n                    else if (Array.isArray(searchTerms) &&\n                        searchTerms.length === 1 &&\n                        typeof searchTerms[0] === 'string' &&\n                        searchTerms[0].indexOf('..') >= 0) {\n                        if (operator !== OperatorType.rangeInclusive && operator !== OperatorType.rangeExclusive) {\n                            operator = this._gridOptions.defaultFilterRangeOperator ?? OperatorType.rangeInclusive;\n                        }\n                        searchTerms = searchTerms[0].split('..', 2);\n                        if (searchTerms[0] === '') {\n                            operator = operator === OperatorType.rangeInclusive ? '<=' : operator === OperatorType.rangeExclusive ? '<' : operator;\n                            searchTerms = searchTerms.slice(1);\n                            searchValue = searchTerms[0];\n                        }\n                        else if (searchTerms[1] === '') {\n                            operator = operator === OperatorType.rangeInclusive ? '>=' : operator === OperatorType.rangeExclusive ? '>' : operator;\n                            searchTerms = searchTerms.slice(0, 1);\n                            searchValue = searchTerms[0];\n                        }\n                    }\n                    if (typeof searchValue === 'string') {\n                        if (operator === '*' || operator === 'a*' || operator === '*z' || lastValueChar === '*') {\n                            operator = (operator === '*' || operator === '*z' ? 'EndsWith' : 'StartsWith');\n                        }\n                    }\n                    // if we didn't find an Operator but we have a Column Operator inside the Filter (DOM Element), we should use its default Operator\n                    // multipleSelect is \"IN\", while singleSelect is \"EQ\", else don't map any operator\n                    if (!operator && columnDef.filter && columnDef.filter.operator) {\n                        operator = columnDef.filter.operator;\n                    }\n                    // No operator and 2 search terms should lead to default range operator.\n                    if (!operator && Array.isArray(searchTerms) && searchTerms.length === 2 && searchTerms[0] && searchTerms[1]) {\n                        operator = this._gridOptions.defaultFilterRangeOperator;\n                    }\n                    // Range with 1 searchterm should lead to equals for a date field.\n                    if ((operator === OperatorType.rangeInclusive || operator === OperatorType.rangeExclusive) &&\n                        Array.isArray(searchTerms) &&\n                        searchTerms.length === 1 &&\n                        fieldType === FieldType.date) {\n                        operator = OperatorType.equal;\n                    }\n                    // Normalize all search values\n                    searchValue = this.normalizeSearchValue(fieldType, searchValue);\n                    if (Array.isArray(searchTerms)) {\n                        searchTerms.forEach((_part, index) => {\n                            searchTerms[index] = this.normalizeSearchValue(fieldType, searchTerms[index]);\n                        });\n                    }\n                    // StartsWith + EndsWith combo\n                    if (operator === OperatorType.startsWithEndsWith && Array.isArray(searchTerms) && searchTerms.length === 2) {\n                        // add 2 conditions (StartsWith A + EndsWith B) to the search array\n                        searchByArray.push({\n                            field: getHtmlStringOutput(fieldName),\n                            operator: OperatorType.startsWith,\n                            value: comboStartsWith,\n                        });\n                        searchByArray.push({ field: getHtmlStringOutput(fieldName), operator: OperatorType.endsWith, value: comboEndsWith });\n                        continue;\n                    }\n                    // when having more than 1 search term (we need to create a CSV string for GraphQL \"IN\" or \"NOT IN\" filter search)\n                    if (searchTerms?.length > 1 && (operator === 'IN' || operator === 'NIN' || operator === 'NOT_IN')) {\n                        searchValue = searchTerms.join(',');\n                    }\n                    else if (searchTerms?.length === 2 && (operator === OperatorType.rangeExclusive || operator === OperatorType.rangeInclusive)) {\n                        searchByArray.push({\n                            field: getHtmlStringOutput(fieldName),\n                            operator: operator === OperatorType.rangeInclusive ? 'GE' : 'GT',\n                            value: searchTerms[0],\n                        });\n                        searchByArray.push({\n                            field: getHtmlStringOutput(fieldName),\n                            operator: operator === OperatorType.rangeInclusive ? 'LE' : 'LT',\n                            value: searchTerms[1],\n                        });\n                        continue;\n                    }\n                    // if we still don't have an operator find the proper Operator to use according field type\n                    if (!operator) {\n                        operator = mapOperatorByFieldType(fieldType);\n                    }\n                    // build the search array\n                    searchByArray.push({ field: getHtmlStringOutput(fieldName), operator: mapOperatorType(operator), value: searchValue });\n                }\n            }\n        }\n        // update the service options with filters for the buildQuery() to work later\n        this.updateOptions({ filteringOptions: searchByArray });\n    }\n    /**\n     * Update the pagination component with it's new page number and size.\n     * @param {Number} newPage\n     * @param {Number} pageSize\n     * @param {*} [cursorArgs] these should be supplied when using cursor based pagination\n     */\n    updatePagination(newPage, pageSize, cursorArgs) {\n        this._currentPagination = {\n            pageNumber: newPage,\n            pageSize,\n        };\n        let paginationOptions = {};\n        if (this.options?.useCursor) {\n            // use cursor based pagination\n            // when using cursor pagination, expect to be given a PaginationCursorChangedArgs as arguments,\n            // but still handle the case where it's not (can happen when initial configuration not pre-configured (automatically corrects itself next setCursorPageInfo() call))\n            if (cursorArgs && cursorArgs instanceof Object) {\n                // remove pageSize and newPage from cursorArgs, otherwise they get put on the query input string\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const { pageSize, newPage, ...cursorPaginationOptions } = cursorArgs;\n                paginationOptions = cursorPaginationOptions;\n            }\n            else {\n                paginationOptions = { first: pageSize };\n            }\n        }\n        else {\n            // use offset based pagination\n            paginationOptions = {\n                first: pageSize,\n                offset: newPage > 1 ? (newPage - 1) * pageSize : 0, // recalculate offset but make sure the result is always over 0\n            };\n        }\n        this.updateOptions({ paginationOptions });\n    }\n    /**\n     * Update all Sorting by looping through all columns to inspect sorters & update backend service sortingOptions\n     */\n    updateSorters(sortColumns, presetSorters) {\n        let currentSorters = [];\n        const graphqlSorters = [];\n        if (!sortColumns && presetSorters) {\n            // make the presets the current sorters, also make sure that all direction are in uppercase for GraphQL\n            currentSorters = presetSorters;\n            currentSorters.forEach((sorter) => (sorter.direction = sorter.direction.toUpperCase()));\n            // display the correct sorting icons on the UI, for that it requires (columnId, sortAsc) properties\n            const tmpSorterArray = currentSorters.map((sorter) => {\n                const columnDef = this._columnDefinitions?.find((column) => column.id === sorter.columnId);\n                graphqlSorters.push({\n                    field: columnDef ? (columnDef.queryFieldSorter || columnDef.queryField || columnDef.field) + '' : sorter.columnId + '',\n                    direction: sorter.direction,\n                });\n                // return only the column(s) found in the Column Definitions ELSE null\n                if (columnDef) {\n                    return {\n                        columnId: sorter.columnId,\n                        sortAsc: sorter.direction.toUpperCase() === SortDirection.ASC,\n                    };\n                }\n                return null;\n            });\n            // set the sort icons, but also make sure to filter out null values (that happens when columnDef is not found)\n            if (Array.isArray(tmpSorterArray) && this._grid) {\n                this._grid.setSortColumns(tmpSorterArray.filter((sorter) => sorter) || []);\n            }\n        }\n        else if (sortColumns && !presetSorters) {\n            // build the orderBy array, it could be multisort, example\n            // orderBy:[{field: lastName, direction: ASC}, {field: firstName, direction: DESC}]\n            if (Array.isArray(sortColumns) && sortColumns.length > 0) {\n                for (const column of sortColumns) {\n                    if (column && column.sortCol) {\n                        currentSorters.push({\n                            columnId: column.sortCol.id + '',\n                            direction: column.sortAsc ? SortDirection.ASC : SortDirection.DESC,\n                        });\n                        const fieldName = (column.sortCol.queryFieldSorter || column.sortCol.queryField || column.sortCol.field || '') + '';\n                        if (fieldName) {\n                            graphqlSorters.push({\n                                field: fieldName,\n                                direction: column.sortAsc ? SortDirection.ASC : SortDirection.DESC,\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        // keep current Sorters and update the service options with the new sorting\n        this._currentSorters = currentSorters;\n        this.updateOptions({ sortingOptions: graphqlSorters });\n    }\n    /**\n     * A function which takes an input string and removes double quotes only\n     * on certain fields are identified as GraphQL enums (except fields with dot notation)\n     * For example let say we identified (\"direction:\", \"sort\") as word which are GraphQL enum fields\n     * then the result will be:\n     * FROM\n     * query { users (orderBy:[{field:\"firstName\", direction:\"ASC\"} }]) }\n     * TO\n     * query { users (orderBy:[{field: firstName, direction: ASC}})}\n     *\n     * EXCEPTIONS (fields with dot notation \".\" which are inside a \"field:\")\n     * these fields will keep double quotes while everything else will be stripped of double quotes\n     * query { users (orderBy:[{field:\"billing.street.name\", direction: \"ASC\"} }\n     * TO\n     * query { users (orderBy:[{field:\"billing.street.name\", direction: ASC}}\n     * @param inputStr input string\n     * @param enumSearchWords array of enum words to filter\n     * @param keepArgumentFieldDoubleQuotes - do we keep field double quotes? (i.e.: field: \"user.name\")\n     * @returns outputStr output string\n     */\n    trimDoubleQuotesOnEnumField(inputStr, enumSearchWords, keepArgumentFieldDoubleQuotes) {\n        // eslint-disable-next-line\n        const patternWordInQuotes = `\\s?((field:\\s*)?\".*?\")`;\n        let patternRegex = enumSearchWords.join(patternWordInQuotes + '|');\n        patternRegex += patternWordInQuotes; // the last one should also have the pattern but without the pipe \"|\"\n        // example with (field: & direction:):  /field:s?(\".*?\")|direction:s?(\".*?\")/\n        const reg = new RegExp(patternRegex, 'g');\n        return inputStr.replace(reg, (group1) => {\n            // remove double quotes except when the string starts with a \"field:\"\n            let removeDoubleQuotes = true;\n            if (group1.startsWith('field:') && keepArgumentFieldDoubleQuotes) {\n                removeDoubleQuotes = false;\n            }\n            const rep = removeDoubleQuotes ? group1.replace(/\"/g, '') : group1;\n            return rep;\n        });\n    }\n    //\n    // protected functions\n    // -------------------\n    /**\n     * Cast provided filters (could be in multiple formats) into an array of CurrentFilter\n     * @param columnFilters\n     */\n    castFilterToColumnFilters(columnFilters) {\n        // keep current filters & always save it as an array (columnFilters can be an object when it is dealt by SlickGrid Filter)\n        const filtersArray = typeof columnFilters === 'object' ? Object.keys(columnFilters).map((key) => columnFilters[key]) : columnFilters;\n        if (!Array.isArray(filtersArray)) {\n            return [];\n        }\n        return filtersArray.map((filter) => {\n            const tmpFilter = { columnId: filter.columnId || '' };\n            if (filter.operator) {\n                tmpFilter.operator = filter.operator;\n            }\n            if (filter.targetSelector) {\n                tmpFilter.targetSelector = filter.targetSelector;\n            }\n            if (Array.isArray(filter.searchTerms)) {\n                tmpFilter.searchTerms = filter.searchTerms;\n            }\n            return tmpFilter;\n        });\n    }\n    /** Normalizes the search value according to field type. */\n    normalizeSearchValue(fieldType, searchValue) {\n        switch (fieldType) {\n            case FieldType.date:\n            case FieldType.string:\n            case FieldType.text:\n            case FieldType.readonly:\n                if (typeof searchValue === 'string') {\n                    // escape single quotes by doubling them\n                    searchValue = searchValue.replace(/'/g, `''`);\n                }\n                break;\n            case FieldType.integer:\n            case FieldType.number:\n            case FieldType.float:\n                if (typeof searchValue === 'string') {\n                    // Parse a valid decimal from the string.\n                    // Replace double dots with single dots\n                    searchValue = searchValue.replace(/\\.\\./g, '.');\n                    // Remove a trailing dot\n                    searchValue = searchValue.replace(/\\.+$/g, '');\n                    // Prefix a leading dot with 0\n                    searchValue = searchValue.replace(/^\\.+/g, '0.');\n                    // Prefix leading dash dot with -0.\n                    searchValue = searchValue.replace(/^-+\\.+/g, '-0.');\n                    // Remove any non valid decimal characters from the search string\n                    searchValue = searchValue.replace(/(?!^-)[^\\d.]/g, '');\n                    // if nothing left, search for 0\n                    if (searchValue === '' || searchValue === '-') {\n                        searchValue = '0';\n                    }\n                }\n                break;\n        }\n        return searchValue;\n    }\n}\n//# sourceMappingURL=graphql.service.js.map"],"names":["GraphqlQueryBuilder","queryFnName","aliasOrFilter","filters","prop","val","searches","searchKeys","alias","_levelA","_currentValue","index","itemX","propsAA","propS","item","value","obj","sourceA","DEFAULT_ITEMS_PER_PAGE","DEFAULT_PAGE_SIZE","GraphqlService","_a","serviceOptions","pagination","grid","sharedService","columnDefinitions","column","queryQb","QueryBuilder","datasetQb","nodesQb","columnIds","columnsQuery","graphqlNodeFields","edgesQb","pageInfoQb","datasetFilters","paginationOptions","_c","_b","_e","_d","_f","_g","queryArgument","enumSearchProperties","processResult","inputArray","set","o","a","k","output","paginationFirst","_event","args","pageSize","sortColumns","columnFilters","isUpdatedByPresetOrDynamically","searchByArray","searchValue","columnId","columnFilter","columnDef","fieldName","stripTags","fieldType","FieldType","searchTerms","fieldSearchValue","getHtmlStringOutput","matches","comboStartsWith","comboEndsWith","operator","lastValueChar","OperatorType","filterQueryOverride","_part","mapOperatorByFieldType","mapOperatorType","newPage","cursorArgs","cursorPaginationOptions","presetSorters","currentSorters","graphqlSorters","sorter","tmpSorterArray","SortDirection","inputStr","enumSearchWords","keepArgumentFieldDoubleQuotes","patternWordInQuotes","patternRegex","reg","group1","removeDoubleQuotes","filtersArray","key","filter","tmpFilter"],"mappings":"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","x_google_ignoreList":[0,1]}